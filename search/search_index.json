{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pytkdocs","text":"<p>Load Python objects documentation.</p> <p>[!IMPORTANT] This project is deprecated in favor of the much more powerful Griffe project.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pytkdocs\n</code></pre> <p>With <code>uv</code>:</p> <pre><code>uv tool install pytkdocs\n</code></pre> <p>With <code>conda</code>: <pre><code>conda install -c conda-forge pytkdocs\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p><code>pytkdocs</code> accepts JSON on standard input and writes JSON on standard output.</p> <p>Input format:</p> <pre><code>{\n  \"objects\": [\n    {\n      \"path\": \"pytkdocs\",\n      \"new_path_syntax\": false,\n      \"members\": true,\n      \"inherited_members\": false,\n      \"filters\": [\n        \"!^_[^_]\"\n      ],\n      \"docstring_style\": \"google\",\n      \"docstring_options\": {\n        \"replace_admonitions\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>Output format:</p> <pre><code>{\n  \"loading_errors\": [\n    \"string (message)\"\n  ],\n  \"parsing_errors\": {\n    \"string (object)\": [\n      \"string (message)\"\n    ]\n  },\n  \"objects\": [\n    {\n      \"name\": \"pytkdocs\",\n      \"path\": \"pytkdocs\",\n      \"category\": \"module\",\n      \"file_path\": \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\",\n      \"relative_file_path\": \"pytkdocs/__init__.py\",\n      \"properties\": [\n        \"special\"\n      ],\n      \"parent_path\": \"pytkdocs\",\n      \"has_contents\": true,\n      \"docstring\": \"pytkdocs package.\\n\\nLoad Python objects documentation.\",\n      \"docstring_sections\": [\n        {\n          \"type\": \"markdown\",\n          \"value\": \"pytkdocs package.\\n\\nLoad Python objects documentation.\"\n        }\n      ],\n      \"source\": {\n        \"code\": \"\\\"\\\"\\\"\\npytkdocs package.\\n\\nLoad Python objects documentation.\\n\\\"\\\"\\\"\\n\\nfrom typing import List\\n\\n__all__: List[str] = []\\n\",\n        \"line_start\": 1\n      },\n      \"children\": {\n        \"pytkdocs.__all__\": {\n          \"name\": \"__all__\",\n          \"path\": \"pytkdocs.__all__\",\n          \"category\": \"attribute\",\n          \"file_path\": \"/media/data/dev/pawamoy/pytkdocs/src/pytkdocs/__init__.py\",\n          \"relative_file_path\": \"pytkdocs/__init__.py\",\n          \"properties\": [\n            \"special\"\n          ],\n          \"parent_path\": \"pytkdocs\",\n          \"has_contents\": false,\n          \"docstring\": null,\n          \"docstring_sections\": [],\n          \"source\": {},\n          \"children\": {},\n          \"attributes\": [],\n          \"methods\": [],\n          \"functions\": [],\n          \"modules\": [],\n          \"classes\": []\n        }\n      },\n      \"attributes\": [\n        \"pytkdocs.__all__\"\n      ],\n      \"methods\": [],\n      \"functions\": [],\n      \"modules\": [\n        \"pytkdocs.__main__\",\n        \"pytkdocs.cli\",\n        \"pytkdocs.loader\",\n        \"pytkdocs.objects\",\n        \"pytkdocs.parsers\",\n        \"pytkdocs.properties\",\n        \"pytkdocs.serializer\"\n      ],\n      \"classes\": []\n    }\n  ]\n}\n</code></pre>"},{"location":"#command-line","title":"Command-line","text":"<p>Running <code>pytkdocs</code> without argument will read the whole standard input, and output the result once.</p> <p>Running <code>pytkdocs --line-by-line</code> will enter an infinite loop, where at each iteration one line is read on the standard input, and the result is written back on one line. This allows other programs to use <code>pytkdocs</code> in a subprocess, feeding it single lines of JSON, and reading back single lines of JSON as well. This mode was actually implemented specifically for mkdocstrings.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The configuration options available are:</p> <ul> <li> <p><code>new_path_syntax</code>: when set to true, this option forces the use of the new object path syntax,   which uses a colon (<code>:</code>) to delimit modules from other objects.</p> </li> <li> <p><code>filters</code>: filters are regular expressions that allow to select or un-select objects based on their name.   They are applied recursively (on every child of every object).   If the expression starts with an exclamation mark,   it will filter out objects matching it (the exclamation mark is removed before evaluation).   If not, objects matching it are selected.   Every regular expression is performed against every name.   It allows fine-grained filtering. Example:</p> <ul> <li><code>!^_</code>: filter out every object whose name starts with <code>_</code> (private/protected)</li> <li><code>^__</code>: but still select those who start with two <code>_</code> (class-private)</li> <li><code>!^__.*__$</code>: except those who also end with two <code>_</code> (specials)</li> </ul> </li> <li> <p><code>members</code>: this option allows to explicitly select the members of the top-object.   If <code>True</code>, select every members that passes filters. If <code>False</code>, select nothing.   If it's a list of names, select only those members, and apply filters on their children only.</p> </li> <li> <p><code>inherited_members</code>: true or false (default). When enabled, inherited members will be selected as well.</p> </li> <li> <p><code>docstring_style</code>: the docstring style to use when parsing the docstring. <code>google</code>, <code>restructured-text</code><sup>1</sup> and <code>numpy</code><sup>2</sup>.</p> </li> <li> <p><code>docstring_options</code>: options to pass to the docstring parser.</p> <ul> <li><code>replace_admonitions</code> boolean option (default: true). When enabled, this option will   replace titles of an indented block by their Markdown admonition equivalent:   <code>AdmonitionType: Title</code> will become <code>!!! admonitiontype \"Title\"</code>.</li> <li><code>trim_doctest_flags</code> boolean option (default: true). When enabled, all doctest   flags (of the form <code># doctest: +FLAG</code> and <code>&lt;BLANKLINE&gt;</code>) located within python   example blocks will be removed from the parsed output.</li> </ul> <p>The <code>google</code> docstring style accepts both options. The <code>numpy</code> style only accepts <code>trim_doctest_flags</code>. The <code>restructured-text</code> style does not accept any options.</p> </li> </ul> <p><sup>1</sup>: reStructured Text parsing is in active development and is not feature complete yet. <sup>2</sup>: The following sections are currently not supported : <code>Notes</code>, <code>See Also</code>, <code>Warns</code> and <code>References</code>.</p>"},{"location":"#details-on-new_path_syntax","title":"Details on <code>new_path_syntax</code>","text":"<p>Example:</p> New syntax <code>package.module:Class.attribute</code> Old syntax <code>package.module.Class.attribute</code> <ul> <li>If there is a colon is an object's path, <code>pytkdocs</code> splits the path accordingly,   regardless of the value of <code>new_path_syntax</code>.</li> <li>If there isn't a colon, and <code>new_path_syntax</code> is false, <code>pytkdocs</code> uses the   old importing behavior.</li> <li>If there isn't a colon, and <code>new_path_syntax</code> is true, <code>pytkdocs</code> uses the new   importing behavior and therefore considers that the path points to a module.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0165-2025-03-09","title":"0.16.5 - 2025-03-09","text":"<p>Compare with 0.16.4</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Stop using deprecated <code>s</code> AST node attribute (27b0daa by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0164-2025-03-09","title":"0.16.4 - 2025-03-09","text":"<p>Compare with 0.16.3</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Stop using deprecated <code>ast.Str</code> (7b3bace by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0163-2025-03-09","title":"0.16.3 - 2025-03-09","text":"<p>Compare with 0.16.2</p>"},{"location":"changelog/#build","title":"Build","text":"<ul> <li>Drop support for Python 3.8 (b4c5c51 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Don't crash on attribute error when trying to detect field (cd9407f by Timoth\u00e9e Mazzucotelli). Issue-149</li> </ul>"},{"location":"changelog/#0162-2024-09-07","title":"0.16.2 - 2024-09-07","text":"<p>Compare with 0.16.1</p>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Swallow kwargs in all parsers constructors (fe8e96f by Timoth\u00e9e Mazzucotelli).</li> <li>General maintenance (29559e8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0161-2022-03-07","title":"0.16.1 - 2022-03-07","text":"<p>Compare with 0.16.0</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Always return strings (not <code>None</code>) and warn about missing descriptions in numpy parser (50b9597 by Joseph Richardson). Issue #137, PR #138</li> </ul>"},{"location":"changelog/#0160-2022-02-19","title":"0.16.0 - 2022-02-19","text":"<p>Compare with 0.15.0</p>"},{"location":"changelog/#maintenance","title":"Maintenance","text":"<ul> <li>Drop Python 3.6 support (0d39665 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add <code>trim_doctest_flag</code> to google and numpy parsers (0fecc43 by Jeremy Goh). Issue mkdocstrings/mkdocstrings#386, PR #134</li> </ul>"},{"location":"changelog/#0150-2021-12-27","title":"0.15.0 - 2021-12-27","text":"<p>Compare with 0.14.2</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add support for <code>help_text</code> field parameter as docstring for django model fields (01ac524 by mabugaj). References: #127, #129</li> </ul>"},{"location":"changelog/#0142-2021-12-16","title":"0.14.2 - 2021-12-16","text":"<p>Compare with 0.14.1</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Remove upper bounds on production dependencies (22ff7df by Timoth\u00e9e Mazzucotelli). Issue #124, PR #128</li> </ul>"},{"location":"changelog/#0141-2021-12-16","title":"0.14.1 - 2021-12-16","text":"<p>Compare with 0.14.0</p>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Remove upper bounds on development dependencies (e1a4eba by Timoth\u00e9e Mazzucotelli). PR #126. See https://iscinumpy.dev/post/bound-version-constraints/.</li> </ul>"},{"location":"changelog/#0140-2021-10-08","title":"0.14.0 - 2021-10-08","text":"<p>Compare with 0.13.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Add Markdown docstring-style support (06556e3 by Timoth\u00e9e Mazzucotelli). PR #121</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Serialize yields and keyword arguments sections (8fb86d6 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0130-2021-10-06","title":"0.13.0 - 2021-10-06","text":"<p>Compare with 0.12.0</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Support google yields sections (4b99cbc by Timoth\u00e9e Mazzucotelli). Issue #89, PR #116</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Add source to class objects (8931df8 by jakekaplan). PR #120</li> <li>Pass context when parsing class docstring (4a62039 by jakekaplan).PR #118</li> <li>Don't mistakenly return a 'missing annotation' error (4afc97f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Set keyword-only kind on keyword arguments (c5c2ef0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0120-2021-09-21","title":"0.12.0 - 2021-09-21","text":"<p>Compare with 0.11.1</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Include base classes in output (f7f6652 by Brian Koropoff). Issue mkdocstrings#269, PR #108</li> <li>Support \"Keyword Args\" sections for Gooogle-style (0133369 by HacKan). Issue #88, PR #105</li> <li>Allow method descriptors to be serialized as methods (8e1b1b2 by jmrgibson). PR #103</li> <li>Add support for Django models (6416a05 by Micha\u0142 Rokita). Issue #39, PR #101</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Fix getting parent module of decorated functions (88b457f by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#162, PR #109</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Stop recording errors in the loader (3191bac by Timoth\u00e9e Mazzucotelli). Issue #111, PR #114</li> <li>Remove warning about new path style option (14b18be by Timoth\u00e9e Mazzucotelli).</li> <li>Switch preference order between annotation and docstring type (c4f6bdc by Andy Challis, and 75b4024 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#143, PR #110</li> </ul>"},{"location":"changelog/#0111-2021-04-03","title":"0.11.1 - 2021-04-03","text":"<p>Compare with 0.11.0</p>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Remove duplicate dataclass attributes when they have defaults (c0277b2 by Bernhard Stadlbauer). Issue #52, PR #100</li> </ul>"},{"location":"changelog/#0110-2021-02-28","title":"0.11.0 - 2021-02-28","text":"<p>Compare with 0.10.1</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add support for Numpy docstrings (de0424a by Achille M). Issue #7, PR #87</li> </ul>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Fix type annotations parsing (9025438 by Timoth\u00e9e Mazzucotelli). Issue #92, PR #96</li> <li>Fix pydantic type documentation for List/Set/Tuple (b99c661 by Shashank Sharma). Issue #94, PR #95</li> <li>Support cached properties (4052eab by Timoth\u00e9e Mazzucotelli). Issue #86</li> <li>Get inherited properties docstrings from parent class (c88282c by Timoth\u00e9e Mazzucotelli). Issue #90</li> <li>Fix dedent for attributes docstrings (0326005 by Timoth\u00e9e Mazzucotelli). Issue #54, issue mkdocstrings#225</li> </ul>"},{"location":"changelog/#0101-2021-01-03","title":"0.10.1 - 2021-01-03","text":"<p>Compare with 0.10.0</p>"},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Warn when examples section is empty (e1d2dfc by Timoth\u00e9e Mazzucotelli).</li> <li>Allow newer version of dataclasses backport (4392f2e by Patrick Lannigan).</li> <li>Ignore errors parsing c-extension modules (1930054 by Wang Yuzhi).</li> <li>Fix attribute parser for Python 3.9 (ae80e98 by Timoth\u00e9e Mazzucotelli). Issue #73 and #75</li> </ul>"},{"location":"changelog/#0100-2020-12-06","title":"0.10.0 - 2020-12-06","text":"<p>Compare with 0.9.0</p>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Avoid recursion if a class has a reference to itself (c92a791 by Matthew Wardrop).</li> </ul>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>Add initial restructured text docstring parsing (0b58c8d by Patrick Lannigan). Issue #67, PR #71</li> </ul>"},{"location":"changelog/#090-2020-09-28","title":"0.9.0 - 2020-09-28","text":"<p>Compare with 0.8.0</p>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Add <code>new_path_syntax</code> option (a0b677c by Timoth\u00e9e Mazzucotelli).   See: \"Details on <code>new_path_syntax</code>\" in the documentation.   Issue #66.</li> </ul>"},{"location":"changelog/#080-2020-09-25","title":"0.8.0 - 2020-09-25","text":"<p>Compare with 0.7.0</p>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Add async property for coroutine functions (a013c07 by Arthur Pastel). Issue pawamoy/mkdocstrings#151, PR #65</li> </ul>"},{"location":"changelog/#070-2020-07-24","title":"0.7.0 - 2020-07-24","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Fix code detecting dataclass fields (4c4a18b by Timoth\u00e9e Mazzucotelli).</li> <li>Prevent crash in case of empty dataclasses (835c066 by Jared Khan). PR #56</li> <li>Use <code>inspect.cleandoc</code> for stripping docstrings whitespace (8009940 by Jared Khan). Issue #54, PR #55</li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Add support for Marshmallow models (c250466 by Stu Fisher). References: #51</li> </ul>"},{"location":"changelog/#060-2020-06-14","title":"0.6.0 - 2020-06-14","text":"<p>Compare with 0.5.2</p>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Support attributes sections for Google-style docstrings (02c0042 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#052-2020-06-11","title":"0.5.2 - 2020-06-11","text":"<p>Compare with 0.5.1</p>"},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>Ignore exceptions when trying to unwrap (02ba876 by Timoth\u00e9e Mazzucotelli). References: #45</li> </ul>"},{"location":"changelog/#051-2020-06-09","title":"0.5.1 - 2020-06-09","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>Fix parsing tuple unpacking assignment (6535fe8 by Timoth\u00e9e Mazzucotelli). References: #43</li> </ul>"},{"location":"changelog/#050-2020-06-08","title":"0.5.0 - 2020-06-08","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>Fix getting documentation for wrapped objects (09f38a5 by Timoth\u00e9e Mazzucotelli). References: #32</li> <li>Dedent attributes docstrings (1a6809c by Timoth\u00e9e Mazzucotelli). References: #42</li> </ul>"},{"location":"changelog/#code-refactoring_4","title":"Code Refactoring","text":"<ul> <li>Accept any valid loader option in JSON input (b58f4a9 by Timoth\u00e9e Mazzucotelli).</li> <li>Change Pydantic properties names (fa8d2e7 by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor parsers (3caefba by Timoth\u00e9e Mazzucotelli).</li> <li>Don't serialize empty error lists in the result (7bec6c4 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Accept docstring options in JSON input (400af0b by Timoth\u00e9e Mazzucotelli).</li> <li>Retrieve dataclass fields docstrings (09eb224 by Timoth\u00e9e Mazzucotelli). References: #31</li> <li>Add support for class inheritance (inherited members) (1af9a53 by Timoth\u00e9e Mazzucotelli). References: #18, #41</li> <li>Add support for examples section (9521c7f by Iago GR). References: #8</li> <li>As a consequence of the attribute parser refactor: pick attributes without docstrings. References: #11</li> </ul>"},{"location":"changelog/#040-2020-05-17","title":"0.4.0 - 2020-05-17","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>Never attempt to parse a null docstring (aa92668 by Timoth\u00e9e Mazzucotelli). References: #37</li> <li>Restore stdout before printing a traceback (20c21e9 by Timoth\u00e9e Mazzucotelli). References: #36</li> <li>Discard import-time stdout (17f71af by Timoth\u00e9e Mazzucotelli). References: #24</li> <li>Don't allow <code>None</code> for a property's docstring (b5868f8 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix relative path for native namespace packages (a74dccf by Shyam Dwaraknath). References: #19, #22</li> </ul>"},{"location":"changelog/#code-refactoring_5","title":"Code Refactoring","text":"<ul> <li>Layout a docstring parser base (d427bcc by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>Add dataclass and pydantic support (a172ad8 by Shyam Dwaraknath). References: #9, #27</li> </ul>"},{"location":"changelog/#030-2020-04-10","title":"0.3.0 - 2020-04-10","text":"<p>Compare with 0.2.1</p>"},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>Fix parsing of <code>*args</code> and <code>**kwargs</code> (b81c93e by adrienhenry). Related issues/PRs: #20, #21</li> </ul>"},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>Support different indentations and complex markup in docstrings sections (2f53082 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #17</li> </ul>"},{"location":"changelog/#021-2020-04-07","title":"0.2.1 - 2020-04-07","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>Fix forward refs replacement for python &gt; 3.6 (6a90aca by Timoth\u00e9e Mazzucotelli).</li> <li>Handle exception parsing error (d6561f8 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #16</li> </ul>"},{"location":"changelog/#020-2020-03-27","title":"0.2.0 - 2020-03-27","text":"<p>Compare with 0.1.2</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add members and filters options (7af68cc).</li> <li>Read type annotations in docstrings.</li> <li>Add modules' source code to the output (f05290b).</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>The code was refactored for readability and robustness (ef9ba9d).   This is a breaking change as some items in the JSON output have changed:<ul> <li>the object <code>signature</code> value was moved from <code>obj.docstring.signature</code> to <code>obj.signature</code>,</li> <li>the docstring <code>sections</code> value was moved from <code>obj.docstring.sections</code> to <code>obj.docstring_sections</code>,</li> <li>the docstring <code>parsing_errors</code> value was moved from <code>obj.docstring.parsing_errors</code> to <code>obj.docstring_errors</code>,</li> </ul> </li> </ul>"},{"location":"changelog/#012-2020-03-23","title":"0.1.2 - 2020-03-23","text":"<p>Compare with 0.1.1</p>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Catch error when trying to get builtins module file path (48df6bc).</li> </ul>"},{"location":"changelog/#011-2020-03-21","title":"0.1.1 - 2020-03-21","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix 'no parsing_errors attribute in Docstring' error (0c8a986).</li> <li>Handle <code>KeyError</code> when searching for param type annotation in signature (b87fe78).</li> </ul>"},{"location":"changelog/#010-2020-03-20","title":"0.1.0 - 2020-03-20","text":"<p>Compare with first commit</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial contents, moved from <code>mkdocstrings</code> and tweaked a bit.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at dev@pawamoy.fr. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd pytkdocs\nmake setup\n</code></pre> <p>Note</p> <p>If it fails for some reason, you'll need to install uv manually.</p> <p>You can install it with:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv sync</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>make run pytkdocs [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>The entry-point to run commands and tasks is the <code>make</code> Python script, located in the <code>scripts</code> directory. Try running <code>make</code> to show the available commands and tasks. The commands do not need the Python dependencies to be installed, while the tasks do. The cross-platform tasks are written in Python, thanks to duty.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>These projects were used to build pytkdocs. Thank you!</p> <p>Python | uv | copier-uv</p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License docstring_parser Parse Python docstrings in reST, Google and Numpydoc format <code>&gt;=0.7</code> <code>0.16</code> MIT typing_extensions Backported and Experimental Type Hints for Python 3.8+ <code>&gt;=4.1, &gt;=3.7</code> <code>4.12.2</code> Python Software Foundation License"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License annotated-types Reusable constraint types to use with typing.Annotated <code>&gt;=0.6.0</code> <code>0.7.0</code> MIT License ansimarkup Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License appdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=1.4</code> <code>1.4.4</code> MIT asgiref ASGI specs, helper code, and adapters <code>&gt;=3.8.1, &lt;4</code> <code>3.8.1</code> BSD-3-Clause babel Internationalization utilities <code>~=2.10</code> <code>2.17.0</code> BSD-3-Clause build A simple, correct Python build frontend <code>&gt;=1.2</code> <code>1.2.2.post1</code> MIT License cappa Declarative CLI argument parser. <code>&gt;=0.22</code> <code>0.26.6</code> ? certifi Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2025.1.31</code> MPL-2.0 cffi Foreign Function Interface for Python calling C code. <code>&gt;=1.12</code> <code>1.17.1</code> MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&gt;=2, &lt;4</code> <code>3.4.1</code> MIT click Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.8</code> BSD License colorama Cross-platform colored terminal text. <code>0.4.6</code> BSD License coverage Code coverage measurement for Python <code>&gt;=7.5</code> <code>7.6.12</code> Apache-2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. <code>&gt;=2.0</code> <code>44.0.2</code> Apache-2.0 OR BSD-3-Clause Django A high-level Python web framework that encourages rapid development and clean, pragmatic design. <code>&gt;=3.2</code> <code>5.1.7</code> BSD-3-Clause docstring_parser Parse Python docstrings in reST, Google and Numpydoc format <code>&gt;=0.7</code> <code>0.16</code> MIT docutils Docutils -- Python Documentation Utilities <code>&gt;=0.21.2</code> <code>0.21.2</code> Public Domain + Python Software Foundation License + BSD License + GNU General Public License (GPL) duty A simple task runner. <code>&gt;=1.6</code> <code>1.6.0</code> ISC execnet execnet: rapid multi-Python deployment <code>&gt;=2.1</code> <code>2.1.1</code> MIT failprint Run a command, print its output only if it fails. <code>&gt;=0.11, !=1.0.0</code> <code>1.0.3</code> ISC ghp-import Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. <code>&gt;=2.5</code> <code>2.5.3</code> ISC griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.49</code> <code>1.6.0.1.3.1</code> ISC humanize Python humanize utilities <code>&gt;=4.9</code> <code>4.12.1</code> MIT id A tool for generating OIDC identities <code>1.5.0</code> Apache Software License idna Internationalized Domain Names in Applications (IDNA) <code>&gt;=2.5, &lt;4</code> <code>3.10</code> BSD License iniconfig brain-dead simple config-ini parsing <code>2.0.0</code> MIT jaraco.classes Utility functions for Python class constructs <code>3.4.0</code> MIT License jaraco.context Useful decorators and context managers <code>6.0.1</code> MIT License jaraco.functools Functools like those found in stdlib <code>4.1.0</code> MIT License jeepney Low-level, pure Python DBus protocol wrapper. <code>&gt;=0.4.2</code> <code>0.9.0</code> MIT Jinja2 A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.6</code> BSD License keyring Store and access your passwords safely. <code>&gt;=15.1</code> <code>25.6.0</code> MIT License Markdown Python implementation of John Gruber's Markdown. <code>&gt;=3.6</code> <code>3.7</code> BSD License markdown-callouts Markdown extension: a classier syntax for admonitions <code>&gt;=0.4</code> <code>0.4.0</code> MIT markdown-exec Utilities to execute code blocks in Markdown files. <code>&gt;=1.8</code> <code>1.10.0.1.1.0</code> ISC markdown-it-py Python port of markdown-it. Markdown parsing, done right! <code>&gt;=2.2.0</code> <code>3.0.0</code> MIT License MarkupSafe Safely add untrusted strings to HTML/XML markup. <code>&gt;=1.1</code> <code>3.0.2</code> BSD License marshmallow A lightweight library for converting complex datatypes to and from native Python datatypes. <code>&gt;=3.13</code> <code>3.26.1</code> MIT License mdurl Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License mergedeep A deep merge function for \ud83d\udc0d. <code>~=1.3</code> <code>1.3.4</code> MIT License mkdocs Project documentation with Markdown. <code>&gt;=1.6</code> <code>1.6.1</code> BSD-2-Clause mkdocs-autorefs Automatically link across pages in MkDocs. <code>&gt;=1.4</code> <code>1.4.1</code> ISC mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=1.0</code> <code>1.1.0</code> ISC mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.5</code> <code>0.5.0</code> MIT mkdocs-get-deps MkDocs extension that lists all dependencies according to a mkdocs.yml file <code>&gt;=0.2</code> <code>0.2.0</code> MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.6</code> <code>0.6.1</code> MIT mkdocs-material Documentation that simply works <code>&gt;=9.5</code> <code>9.6.5+insiders.4.53.15</code> MIT mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page <code>&gt;=0.3</code> <code>0.3.9</code> MIT mkdocstrings Automatic documentation from sources, for MkDocs. <code>&gt;=0.25</code> <code>0.28.3</code> ISC mkdocstrings-python A Python handler for mkdocstrings. <code>&gt;=1.16.2</code> <code>1.16.2.1.9.1</code> ISC more-itertools More routines for operating on iterables, beyond itertools <code>10.6.0</code> MIT License mypy Optional static typing for Python <code>&gt;=1.10</code> <code>1.15.0</code> MIT mypy-extensions Type system extensions for programs checked with the mypy type checker. <code>&gt;=1.0.0</code> <code>1.0.0</code> MIT License nh3 Python binding to Ammonia HTML sanitizer Rust crate <code>&gt;=0.2.14</code> <code>0.2.21</code> MIT packaging Core utilities for Python packages <code>&gt;=24.0</code> <code>24.2</code> Apache Software License + BSD License paginate Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.7</code> MIT pathspec Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) platformdirs A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=2.2.0</code> <code>4.3.6</code> MIT pluggy plugin and hook calling mechanisms for python <code>&gt;=1.5, &lt;2</code> <code>1.5.0</code> MIT ptyprocess Run a subprocess in a pseudo terminal <code>~=0.6</code> <code>0.7.0</code> ISC License (ISCL) pycparser C parser in Python <code>2.22</code> BSD-3-Clause pydantic Data validation using Python type hints <code>&gt;=1.8</code> <code>2.10.6</code> MIT pydantic_core Core functionality for Pydantic validation and serialization <code>==2.27.2</code> <code>2.27.2</code> MIT Pygments Pygments is a syntax highlighting package written in Python. <code>&gt;=2.5.1</code> <code>2.19.1</code> BSD-2-Clause pymdown-extensions Extension pack for Python Markdown. <code>&gt;=6.3</code> <code>10.14.3</code> MIT pyproject_hooks Wrappers to call pyproject.toml-based build backend hooks. <code>1.2.0</code> MIT License pytest pytest: simple powerful testing with Python <code>&gt;=8.2</code> <code>8.3.5</code> MIT pytest-cov Pytest plugin for measuring coverage. <code>&gt;=5.0</code> <code>6.0.0</code> MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.15</code> <code>3.16.0</code> MIT License pytest-xdist pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=3.6</code> <code>3.6.1</code> MIT License python-dateutil Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> BSD License + Apache Software License PyYAML YAML parser and emitter for Python <code>6.0.2</code> MIT pyyaml_env_tag A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License readme_renderer readme_renderer is a library for rendering readme descriptions for Warehouse <code>&gt;=35.0</code> <code>44.0</code> Apache License, Version 2.0 regex Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2024.11.6</code> Apache Software License requests Python HTTP for Humans. <code>&gt;=2.20</code> <code>2.32.3</code> Apache-2.0 requests-toolbelt A utility belt for advanced users of python-requests <code>&gt;=0.8.0, !=0.9.0</code> <code>1.0.0</code> Apache 2.0 rfc3986 Validating URI References per RFC 3986 <code>&gt;=1.4.0</code> <code>2.0.0</code> Apache 2.0 rich Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.0.0</code> <code>13.9.4</code> MIT ruff An extremely fast Python linter and code formatter, written in Rust. <code>&gt;=0.4</code> <code>0.9.10</code> MIT SecretStorage Python bindings to FreeDesktop.org Secret Service API <code>&gt;=3.2</code> <code>3.3.3</code> BSD 3-Clause License semver Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.4</code> BSD License six Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT sqlparse A non-validating SQL parser. <code>&gt;=0.3.1</code> <code>0.5.3</code> BSD License twine Collection of utilities for publishing packages on PyPI <code>&gt;=5.1</code> <code>6.1.0</code> Apache Software License type-lens type-lens is a Python template project designed to simplify the setup of a new project. <code>&gt;=0.2.3</code> <code>0.2.3</code> MIT types-Markdown Typing stubs for Markdown <code>&gt;=3.6</code> <code>3.7.0.20241204</code> Apache-2.0 types-PyYAML Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.20241230</code> Apache-2.0 typing_extensions Backported and Experimental Type Hints for Python 3.8+ <code>&gt;=4.1, &gt;=3.7</code> <code>4.12.2</code> Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <code>&gt;=1.26.0</code> <code>2.3.0</code> MIT License watchdog Filesystem events monitoring <code>&gt;=2.0</code> <code>6.0.0</code> Apache-2.0 yore Manage legacy code with comments. <code>&gt;=0.3.3</code> <code>0.3.4</code> ISC <p>More credits from the author</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2020, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"reference/pytkdocs/","title":"pytkdocs","text":"<p>pytkdocs package.</p> <p>Load Python objects documentation.</p>"},{"location":"reference/pytkdocs/cli/","title":"pytkdocs.cli","text":"<p>Module that contains the command line application.</p>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.discarded_stdout","title":"<code>discarded_stdout()</code>","text":"<p>Discard standard output.</p> <p>Yields:</p> Name Type Description <code>Nothing</code> <code>None</code> <p>We only yield to act as a context manager.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>@contextmanager\ndef discarded_stdout() -&gt; Iterator[None]:\n    \"\"\"Discard standard output.\n\n    Yields:\n        Nothing: We only yield to act as a context manager.\n    \"\"\"\n    # Discard things printed at import time to avoid corrupting our JSON output\n    # See https://github.com/pawamoy/pytkdocs/issues/24\n    old_stdout = sys.stdout\n    sys.stdout = StringIO()\n\n    yield\n\n    # Flush imported modules' output, and restore true sys.stdout\n    sys.stdout.flush()\n    sys.stdout = old_stdout\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.extract_docstring_parsing_errors","title":"<code>extract_docstring_parsing_errors(errors, obj)</code>","text":"<p>Recursion helper.</p> <p>Update the <code>errors</code> dictionary by side-effect. Recurse on the object's children.</p> <p>Parameters:</p> Name Type Description Default <code>errors</code> <code>dict</code> <p>The dictionary to update.</p> required <code>obj</code> <code>Object</code> <p>The object.</p> required Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def extract_docstring_parsing_errors(errors: dict, obj: Object) -&gt; None:\n    \"\"\"Recursion helper.\n\n    Update the `errors` dictionary by side-effect. Recurse on the object's children.\n\n    Arguments:\n        errors: The dictionary to update.\n        obj: The object.\n    \"\"\"\n    if hasattr(obj, \"docstring_errors\") and obj.docstring_errors:\n        errors[obj.path] = obj.docstring_errors\n    for child in obj.children:\n        extract_docstring_parsing_errors(errors, child)\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.extract_errors","title":"<code>extract_errors(obj)</code>","text":"<p>Extract the docstring parsing errors of each object, recursively, into a flat dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>An object from <code>pytkdocs.objects</code>.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A flat dictionary. Keys are the objects' names.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def extract_errors(obj: Object) -&gt; dict:\n    \"\"\"Extract the docstring parsing errors of each object, recursively, into a flat dictionary.\n\n    Arguments:\n        obj: An object from `pytkdocs.objects`.\n\n    Returns:\n        A flat dictionary. Keys are the objects' names.\n    \"\"\"\n    parsing_errors: dict[str, list[str]] = {}\n    extract_docstring_parsing_errors(parsing_errors, obj)\n    return parsing_errors\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.get_parser","title":"<code>get_parser()</code>","text":"<p>Return the program argument parser.</p> <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>The argument parser for the program.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"Return the program argument parser.\n\n    Returns:\n        The argument parser for the program.\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"pytkdocs\")\n    parser.add_argument(\n        \"-1\",\n        \"--line-by-line\",\n        action=\"store_true\",\n        dest=\"line_by_line\",\n        help=\"Process each line read on stdin, one by one.\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=f\"%(prog)s {debug.get_version()}\")\n    parser.add_argument(\"--debug-info\", action=_DebugInfo, help=\"Print debug information.\")\n    return parser\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.main","title":"<code>main(args=None)</code>","text":"<p>Run the main program.</p> <p>This function is executed when you type <code>pytkdocs</code> or <code>python -m pytkdocs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments passed from the command line.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>An exit code.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n    \"\"\"Run the main program.\n\n    This function is executed when you type `pytkdocs` or `python -m pytkdocs`.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    parser = get_parser()\n    parsed_args: argparse.Namespace = parser.parse_args(args)\n\n    if parsed_args.line_by_line:\n        for line in sys.stdin:\n            with discarded_stdout():\n                try:\n                    output = json.dumps(process_json(line))\n                except Exception as error:  # noqa: BLE001\n                    # Don't fail on error. We must handle the next inputs.\n                    # Instead, print error as JSON.\n                    output = json.dumps({\"error\": str(error), \"traceback\": traceback.format_exc()})\n            print(output)\n    else:\n        with discarded_stdout():\n            output = json.dumps(process_json(sys.stdin.read()))\n        print(output)\n\n    return 0\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.process_config","title":"<code>process_config(config)</code>","text":"<p>Process a loading configuration.</p> <p>The <code>config</code> argument is a dictionary looking like this:</p> <pre><code>{\n    \"objects\": [\n        {\"path\": \"python.dotted.path.to.the.object1\"},\n        {\"path\": \"python.dotted.path.to.the.object2\"},\n    ]\n}\n</code></pre> <p>The result is a dictionary looking like this:</p> <pre><code>{\n    \"loading_errors\": [\n        \"message1\",\n        \"message2\",\n    ],\n    \"parsing_errors\": {\n        \"path.to.object1\": [\n            \"message1\",\n            \"message2\",\n        ],\n        \"path.to.object2\": [\n            \"message1\",\n            \"message2\",\n        ],\n    },\n    \"objects\": [\n        {\n            \"path\": \"path.to.object1\",\n            # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer`\n        },\n        {\n            \"path\": \"path.to.object2\",\n            # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer`\n        },\n    ],\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The collected documentation along with the errors that occurred.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def process_config(config: dict) -&gt; dict:\n    \"\"\"Process a loading configuration.\n\n    The `config` argument is a dictionary looking like this:\n\n    ```python\n    {\n        \"objects\": [\n            {\"path\": \"python.dotted.path.to.the.object1\"},\n            {\"path\": \"python.dotted.path.to.the.object2\"},\n        ]\n    }\n    ```\n\n    The result is a dictionary looking like this:\n\n    ```python\n    {\n        \"loading_errors\": [\n            \"message1\",\n            \"message2\",\n        ],\n        \"parsing_errors\": {\n            \"path.to.object1\": [\n                \"message1\",\n                \"message2\",\n            ],\n            \"path.to.object2\": [\n                \"message1\",\n                \"message2\",\n            ],\n        },\n        \"objects\": [\n            {\n                \"path\": \"path.to.object1\",\n                # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer`\n            },\n            {\n                \"path\": \"path.to.object2\",\n                # other attributes, see the documentation for `pytkdocs.objects` or `pytkdocs.serializer`\n            },\n        ],\n    }\n    ```\n\n    Arguments:\n        config: The configuration.\n\n    Returns:\n        The collected documentation along with the errors that occurred.\n    \"\"\"\n    collected = []\n    loading_errors = []\n    parsing_errors = {}\n\n    for obj_config in config[\"objects\"]:\n        path = obj_config.pop(\"path\")\n        members = obj_config.pop(\"members\", set())\n\n        if isinstance(members, list):\n            members = set(members)\n        loader = Loader(**obj_config)\n\n        obj = loader.get_object_documentation(path, members)\n\n        loading_errors.extend(loader.errors)\n        parsing_errors.update(extract_errors(obj))\n\n        serialized_obj = serialize_object(obj)\n        collected.append(serialized_obj)\n\n    return {\"loading_errors\": loading_errors, \"parsing_errors\": parsing_errors, \"objects\": collected}\n</code></pre>"},{"location":"reference/pytkdocs/cli/#pytkdocs.cli.process_json","title":"<code>process_json(json_input)</code>","text":"<p>Process JSON input.</p> <p>Simply load the JSON as a Python dictionary, then pass it to <code>process_config</code>.</p> <p>Parameters:</p> Name Type Description Default <code>json_input</code> <code>str</code> <p>The JSON to load.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The result of the call to <code>process_config</code>.</p> Source code in <code>src/pytkdocs/cli.py</code> <pre><code>def process_json(json_input: str) -&gt; dict:\n    \"\"\"Process JSON input.\n\n    Simply load the JSON as a Python dictionary, then pass it to [`process_config`][pytkdocs.cli.process_config].\n\n    Arguments:\n        json_input: The JSON to load.\n\n    Returns:\n        The result of the call to [`process_config`][pytkdocs.cli.process_config].\n    \"\"\"\n    return process_config(json.loads(json_input))\n</code></pre>"},{"location":"reference/pytkdocs/debug/","title":"pytkdocs.debug","text":"<p>Debugging utilities.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment","title":"<code>Environment</code>  <code>dataclass</code>","text":"<p>Dataclass to store environment information.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>@dataclass\nclass Environment:\n    \"\"\"Dataclass to store environment information.\"\"\"\n\n    interpreter_name: str\n    \"\"\"Python interpreter name.\"\"\"\n    interpreter_version: str\n    \"\"\"Python interpreter version.\"\"\"\n    interpreter_path: str\n    \"\"\"Path to Python executable.\"\"\"\n    platform: str\n    \"\"\"Operating System.\"\"\"\n    packages: list[Package]\n    \"\"\"Installed packages.\"\"\"\n    variables: list[Variable]\n    \"\"\"Environment variables.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.interpreter_name","title":"<code>interpreter_name</code>  <code>instance-attribute</code>","text":"<p>Python interpreter name.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.interpreter_path","title":"<code>interpreter_path</code>  <code>instance-attribute</code>","text":"<p>Path to Python executable.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.interpreter_version","title":"<code>interpreter_version</code>  <code>instance-attribute</code>","text":"<p>Python interpreter version.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.packages","title":"<code>packages</code>  <code>instance-attribute</code>","text":"<p>Installed packages.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.platform","title":"<code>platform</code>  <code>instance-attribute</code>","text":"<p>Operating System.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Environment.variables","title":"<code>variables</code>  <code>instance-attribute</code>","text":"<p>Environment variables.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Package","title":"<code>Package</code>  <code>dataclass</code>","text":"<p>Dataclass describing a Python package.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>@dataclass\nclass Package:\n    \"\"\"Dataclass describing a Python package.\"\"\"\n\n    name: str\n    \"\"\"Package name.\"\"\"\n    version: str\n    \"\"\"Package version.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Package.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Package name.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Package.version","title":"<code>version</code>  <code>instance-attribute</code>","text":"<p>Package version.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>Dataclass describing an environment variable.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>@dataclass\nclass Variable:\n    \"\"\"Dataclass describing an environment variable.\"\"\"\n\n    name: str\n    \"\"\"Variable name.\"\"\"\n    value: str\n    \"\"\"Variable value.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Variable.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Variable name.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.Variable.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>Variable value.</p>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.get_debug_info","title":"<code>get_debug_info()</code>","text":"<p>Get debug/environment information.</p> <p>Returns:</p> Type Description <code>Environment</code> <p>Environment information.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>def get_debug_info() -&gt; Environment:\n    \"\"\"Get debug/environment information.\n\n    Returns:\n        Environment information.\n    \"\"\"\n    py_name, py_version = _interpreter_name_version()\n    packages = [\"pytkdocs\"]\n    variables = [\"PYTHONPATH\", *[var for var in os.environ if var.startswith(\"PYTKDOCS\")]]\n    return Environment(\n        interpreter_name=py_name,\n        interpreter_version=py_version,\n        interpreter_path=sys.executable,\n        platform=platform.platform(),\n        variables=[Variable(var, val) for var in variables if (val := os.getenv(var))],\n        packages=[Package(pkg, get_version(pkg)) for pkg in packages],\n    )\n</code></pre>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.get_version","title":"<code>get_version(dist='pytkdocs')</code>","text":"<p>Get version of the given distribution.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>str</code> <p>A distribution name.</p> <code>'pytkdocs'</code> <p>Returns:</p> Type Description <code>str</code> <p>A version number.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>def get_version(dist: str = \"pytkdocs\") -&gt; str:\n    \"\"\"Get version of the given distribution.\n\n    Parameters:\n        dist: A distribution name.\n\n    Returns:\n        A version number.\n    \"\"\"\n    try:\n        return metadata.version(dist)\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/pytkdocs/debug/#pytkdocs.debug.print_debug_info","title":"<code>print_debug_info()</code>","text":"<p>Print debug/environment information.</p> Source code in <code>src/pytkdocs/debug.py</code> <pre><code>def print_debug_info() -&gt; None:\n    \"\"\"Print debug/environment information.\"\"\"\n    info = get_debug_info()\n    print(f\"- __System__: {info.platform}\")\n    print(f\"- __Python__: {info.interpreter_name} {info.interpreter_version} ({info.interpreter_path})\")\n    print(\"- __Environment variables__:\")\n    for var in info.variables:\n        print(f\"  - `{var.name}`: `{var.value}`\")\n    print(\"- __Installed packages__:\")\n    for pkg in info.packages:\n        print(f\"  - `{pkg.name}` v{pkg.version}\")\n</code></pre>"},{"location":"reference/pytkdocs/loader/","title":"pytkdocs.loader","text":"<p>This module is responsible for loading the documentation from Python objects.</p> <p>It uses <code>inspect</code> for introspecting objects, iterating over their members, etc.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader","title":"<code>Loader</code>","text":"<p>This class contains the object documentation loading mechanisms.</p> <p>Any error that occurred during collection of the objects and their documentation is stored in the <code>errors</code> list.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>class Loader:\n    \"\"\"This class contains the object documentation loading mechanisms.\n\n    Any error that occurred during collection of the objects and their documentation is stored in the `errors` list.\n    \"\"\"\n\n    def __init__(\n        self,\n        filters: Optional[list[str]] = None,\n        docstring_style: str = \"google\",\n        docstring_options: Optional[dict] = None,\n        inherited_members: bool = False,  # noqa: FBT001, FBT002\n        new_path_syntax: bool = False,  # noqa: FBT001, FBT002\n    ) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            filters: A list of regular expressions to fine-grain select members. It is applied recursively.\n            docstring_style: The style to use when parsing docstrings.\n            docstring_options: The options to pass to the docstrings parser.\n            inherited_members: Whether to select inherited members for classes.\n            new_path_syntax: Whether to use the \"colon\" syntax for the path.\n        \"\"\"\n        if not filters:\n            filters = []\n\n        self.filters = [(filtr, re.compile(filtr.lstrip(\"!\"))) for filtr in filters]\n        self.docstring_parser = PARSERS[docstring_style](**(docstring_options or {}))\n        self.errors: list[str] = []\n        self.select_inherited_members = inherited_members\n        self.new_path_syntax = new_path_syntax\n\n    def get_object_documentation(self, dotted_path: str, members: Optional[Union[set[str], bool]] = None) -&gt; Object:\n        \"\"\"Get the documentation for an object and its children.\n\n        Arguments:\n            dotted_path: The Python dotted path to the desired object.\n            members: `True` to select members and filter them, `False` to select no members,\n                or a list of names to explicitly select the members with these names.\n                It is applied only on the root object.\n\n        Returns:\n            The documented object.\n        \"\"\"\n        if members is True:\n            members = set()\n\n        root_object: Object\n        leaf = get_object_tree(dotted_path, self.new_path_syntax)\n\n        if leaf.is_module():\n            root_object = self.get_module_documentation(leaf, members)\n        elif leaf.is_class():\n            root_object = self.get_class_documentation(leaf, members)\n        elif leaf.is_staticmethod():\n            root_object = self.get_staticmethod_documentation(leaf)\n        elif leaf.is_classmethod():\n            root_object = self.get_classmethod_documentation(leaf)\n        elif leaf.is_method_descriptor() or leaf.is_method():\n            root_object = self.get_regular_method_documentation(leaf)\n        elif leaf.is_function():\n            root_object = self.get_function_documentation(leaf)\n        elif leaf.is_property():\n            root_object = self.get_property_documentation(leaf)\n        else:\n            root_object = self.get_attribute_documentation(leaf)\n\n        root_object.parse_all_docstrings(self.docstring_parser)\n\n        return root_object\n\n    def get_module_documentation(\n        self,\n        node: ObjectNode,\n        select_members: Optional[Union[set[str], bool]] = None,\n    ) -&gt; Module:\n        \"\"\"Get the documentation for a module and its children.\n\n        Arguments:\n            node: The node representing the module and its parents.\n            select_members: Explicit members to select.\n\n        Returns:\n            The documented module object.\n        \"\"\"\n        module = node.obj\n        path = node.dotted_path\n        name = path.split(\".\")[-1]\n        source: Optional[Source]\n\n        try:\n            source = Source(inspect.getsource(module), 1)\n        except OSError:\n            try:\n                code = Path(node.file_path).read_text()\n            except (OSError, UnicodeDecodeError):\n                source = None\n            else:\n                source = Source(code, 1) if code else None\n\n        root_object = Module(\n            name=name,\n            path=path,\n            file_path=node.file_path,\n            docstring=inspect.getdoc(module),\n            source=source,\n        )\n\n        if select_members is False:\n            return root_object\n\n        select_members = select_members or set()\n\n        attributes_data = get_module_attributes(module)\n        root_object.parse_docstring(self.docstring_parser, attributes=attributes_data)\n\n        for member_name, member in inspect.getmembers(module):\n            if self.select(member_name, select_members):  # type: ignore[arg-type]\n                child_node = ObjectNode(member, member_name, parent=node)\n                if child_node.is_class() and node.root.obj is inspect.getmodule(child_node.obj):\n                    root_object.add_child(self.get_class_documentation(child_node))\n                elif child_node.is_function() and node.root.obj is inspect.getmodule(child_node.obj):\n                    root_object.add_child(self.get_function_documentation(child_node))\n                elif member_name in attributes_data:\n                    root_object.add_child(self.get_attribute_documentation(child_node, attributes_data[member_name]))\n\n        if hasattr(module, \"__path__\"):\n            for _, modname, _ in pkgutil.iter_modules(module.__path__):\n                if self.select(modname, select_members):  # type: ignore[arg-type]\n                    leaf = get_object_tree(f\"{path}.{modname}\")\n                    root_object.add_child(self.get_module_documentation(leaf))\n\n        return root_object\n\n    @staticmethod\n    def _class_path(cls: type) -&gt; str:  # noqa: PLW0211\n        mod = cls.__module__\n        qname = cls.__qualname__\n        if mod == \"builtins\":\n            return qname\n        return f\"{mod}.{qname}\"\n\n    def get_class_documentation(\n        self,\n        node: ObjectNode,\n        select_members: Optional[Union[set[str], bool]] = None,\n    ) -&gt; Class:\n        \"\"\"Get the documentation for a class and its children.\n\n        Arguments:\n            node: The node representing the class and its parents.\n            select_members: Explicit members to select.\n\n        Returns:\n            The documented class object.\n        \"\"\"\n        class_ = node.obj\n        docstring = inspect.cleandoc(class_.__doc__ or \"\")\n        bases = [self._class_path(b) for b in class_.__bases__]\n\n        source: Optional[Source]\n\n        try:\n            source = Source(*inspect.getsourcelines(node.obj))\n        except (OSError, TypeError):\n            source = None\n\n        root_object = Class(\n            name=node.name,\n            path=node.dotted_path,\n            file_path=node.file_path,\n            docstring=docstring,\n            bases=bases,\n            source=source,\n        )\n\n        # Even if we don't select members, we want to correctly parse the docstring\n        attributes_data: dict[str, dict[str, Any]] = {}\n        for parent_class in reversed(class_.__mro__[:-1]):\n            merge(attributes_data, get_class_attributes(parent_class))\n        context: dict[str, Any] = {\"attributes\": attributes_data}\n        if \"__init__\" in class_.__dict__:\n            try:\n                attributes_data.update(get_instance_attributes(class_.__init__))\n                context[\"signature\"] = inspect.signature(class_.__init__)\n            except (TypeError, ValueError):\n                pass\n        root_object.parse_docstring(self.docstring_parser, **context)\n\n        if select_members is False:\n            return root_object\n\n        select_members = select_members or set()\n\n        # Build the list of members\n        members = {}\n        inherited = set()\n        direct_members = class_.__dict__\n        all_members = dict(inspect.getmembers(class_))\n        for member_name, member in all_members.items():\n            if member is class_:\n                continue\n            if not (member is type or member is object) and self.select(member_name, select_members):  # type: ignore[arg-type]\n                if member_name not in direct_members:\n                    if self.select_inherited_members:\n                        members[member_name] = member\n                        inherited.add(member_name)\n                else:\n                    members[member_name] = member\n\n        # Iterate on the selected members\n        child: Object\n        for member_name, member in members.items():\n            child_node = ObjectNode(member, member_name, parent=node)\n            if child_node.is_class():\n                child = self.get_class_documentation(child_node)\n            elif child_node.is_classmethod():\n                child = self.get_classmethod_documentation(child_node)\n            elif child_node.is_staticmethod():\n                child = self.get_staticmethod_documentation(child_node)\n            elif child_node.is_method():\n                child = self.get_regular_method_documentation(child_node)\n            elif child_node.is_property():\n                child = self.get_property_documentation(child_node)\n            elif member_name in attributes_data:\n                child = self.get_attribute_documentation(child_node, attributes_data[member_name])\n            else:\n                continue\n            if member_name in inherited:\n                child.properties.append(\"inherited\")\n            root_object.add_child(child)\n\n        for attr_name, properties, add_method in (\n            (\"__fields__\", [\"pydantic-model\"], self.get_pydantic_field_documentation),\n            (\"_declared_fields\", [\"marshmallow-model\"], self.get_marshmallow_field_documentation),\n            (\"_meta.get_fields\", [\"django-model\"], self.get_django_field_documentation),\n            (\"__dataclass_fields__\", [\"dataclass\"], self.get_annotated_dataclass_field),\n        ):\n            if self.detect_field_model(attr_name, direct_members, all_members):\n                root_object.properties.extend(properties)\n                self.add_fields(\n                    node,\n                    root_object,\n                    attr_name,\n                    all_members,\n                    select_members,\n                    class_,\n                    add_method,\n                )\n                break\n\n        return root_object\n\n    def detect_field_model(self, attr_name: str, direct_members: Sequence[str], all_members: dict) -&gt; bool:\n        \"\"\"Detect if an attribute is present in members.\n\n        Arguments:\n            attr_name: The name of the attribute to detect, can contain dots.\n            direct_members: The direct members of the class.\n            all_members: All members of the class.\n\n        Returns:\n            Whether the attribute is present.\n        \"\"\"\n        first_order_attr_name, remainder = split_attr_name(attr_name)\n        if not (\n            first_order_attr_name in direct_members\n            or (self.select_inherited_members and first_order_attr_name in all_members)\n        ):\n            return False\n\n        if remainder:\n            with suppress(AttributeError):\n                return bool(attrgetter(remainder)(all_members[first_order_attr_name]))\n        return True\n\n    def add_fields(\n        self,\n        node: ObjectNode,\n        root_object: Object,\n        attr_name: str,\n        members: Mapping[str, Any],\n        select_members: Optional[Union[set[str], bool]],\n        base_class: type,\n        add_method: Callable,\n    ) -&gt; None:\n        \"\"\"Add detected fields to the current object.\n\n        Arguments:\n            node: The current object node.\n            root_object: The current object.\n            attr_name: The fields attribute name.\n            members: The members to pick the fields attribute in.\n            select_members: The members to select.\n            base_class: The class declaring the fields.\n            add_method: The method to add the children object.\n        \"\"\"\n        fields = get_fields(attr_name, members=members)\n\n        for field_name, field in fields.items():\n            select_field = self.select(field_name, select_members)  # type: ignore[arg-type]\n            is_inherited = field_is_inherited(field_name, attr_name, base_class)\n\n            if select_field and (self.select_inherited_members or not is_inherited):\n                child_node = ObjectNode(obj=field, name=field_name, parent=node)\n                root_object.add_child(add_method(child_node))\n\n    def get_function_documentation(self, node: ObjectNode) -&gt; Function:\n        \"\"\"Get the documentation for a function.\n\n        Arguments:\n            node: The node representing the function and its parents.\n\n        Returns:\n            The documented function object.\n        \"\"\"\n        function = node.obj\n        source: Optional[Source]\n        signature: Optional[inspect.Signature]\n\n        try:\n            signature = inspect.signature(function)\n        except TypeError:\n            signature = None\n\n        try:\n            source = Source(*inspect.getsourcelines(function))\n        except OSError:\n            source = None\n\n        properties: list[str] = []\n        if node.is_coroutine_function():\n            properties.append(\"async\")\n\n        return Function(\n            name=node.name,\n            path=node.dotted_path,\n            file_path=node.file_path,\n            docstring=inspect.getdoc(function),\n            signature=signature,\n            source=source,\n            properties=properties,\n        )\n\n    def get_property_documentation(self, node: ObjectNode) -&gt; Attribute:\n        \"\"\"Get the documentation for a property.\n\n        Arguments:\n            node: The node representing the property and its parents.\n\n        Returns:\n            The documented attribute object (properties are considered attributes for now).\n        \"\"\"\n        prop = node.obj\n        path = node.dotted_path\n        properties = [\"property\"]\n        if node.is_cached_property():\n            # cached_property is always writable, see the docs\n            properties.extend([\"writable\", \"cached\"])\n            sig_source_func = prop.func\n        else:\n            properties.append(\"readonly\" if prop.fset is None else \"writable\")\n            sig_source_func = prop.fget\n\n        source: Optional[Source]\n\n        try:\n            signature = inspect.signature(sig_source_func)\n        except (TypeError, ValueError):\n            attr_type = None\n        else:\n            attr_type = signature.return_annotation\n\n        try:\n            source = Source(*inspect.getsourcelines(sig_source_func))\n        except (OSError, TypeError):\n            source = None\n\n        return Attribute(\n            name=node.name,\n            path=path,\n            file_path=node.file_path,\n            docstring=inspect.getdoc(prop),\n            attr_type=attr_type,\n            properties=properties,\n            source=source,\n        )\n\n    @staticmethod\n    def get_pydantic_field_documentation(node: ObjectNode) -&gt; Attribute:\n        \"\"\"Get the documentation for a Pydantic Field.\n\n        Arguments:\n            node: The node representing the Field and its parents.\n\n        Returns:\n            The documented attribute object.\n        \"\"\"\n        prop = node.obj\n        path = node.dotted_path\n        properties = [\"pydantic-field\"]\n        if prop.required:\n            properties.append(\"required\")\n\n        return Attribute(\n            name=node.name,\n            path=path,\n            file_path=node.file_path,\n            docstring=prop.field_info.description,\n            attr_type=prop.outer_type_,\n            properties=properties,\n        )\n\n    @staticmethod\n    def get_django_field_documentation(node: ObjectNode) -&gt; Attribute:\n        \"\"\"Get the documentation for a Django Field.\n\n        Arguments:\n            node: The node representing the Field and its parents.\n\n        Returns:\n            The documented attribute object.\n        \"\"\"\n        prop = node.obj\n        path = node.dotted_path\n        properties = [\"django-field\"]\n\n        if prop.null:\n            properties.append(\"nullable\")\n        if prop.blank:\n            properties.append(\"blank\")\n\n        # set correct docstring based on verbose_name and help_text\n        # both should be converted to str type in case lazy translation\n        # is being used, which is common scenario in django\n        docstring = f\"{prop.verbose_name}: {prop.help_text}\" if prop.help_text else str(prop.verbose_name)\n\n        return Attribute(\n            name=node.name,\n            path=path,\n            file_path=node.file_path,\n            docstring=docstring,\n            attr_type=prop.__class__,\n            properties=properties,\n        )\n\n    @staticmethod\n    def get_marshmallow_field_documentation(node: ObjectNode) -&gt; Attribute:\n        \"\"\"Get the documentation for a Marshmallow Field.\n\n        Arguments:\n            node: The node representing the Field and its parents.\n\n        Returns:\n            The documented attribute object.\n        \"\"\"\n        prop = node.obj\n        path = node.dotted_path\n        properties = [\"marshmallow-field\"]\n        if prop.required:\n            properties.append(\"required\")\n\n        return Attribute(\n            name=node.name,\n            path=path,\n            file_path=node.file_path,\n            docstring=prop.metadata.get(\"description\"),\n            attr_type=type(prop),\n            properties=properties,\n        )\n\n    @staticmethod\n    def get_annotated_dataclass_field(node: ObjectNode, attribute_data: Optional[dict] = None) -&gt; Attribute:\n        \"\"\"Get the documentation for a dataclass field.\n\n        Arguments:\n            node: The node representing the annotation and its parents.\n            attribute_data: Docstring and annotation for this attribute.\n\n        Returns:\n            The documented attribute object.\n        \"\"\"\n        if attribute_data is None:\n            if node.parent_is_class():\n                attribute_data = get_class_attributes(node.parent.obj).get(node.name, {})  # type: ignore[union-attr]\n            else:\n                attribute_data = get_module_attributes(node.root.obj).get(node.name, {})\n\n        return Attribute(\n            name=node.name,\n            path=node.dotted_path,\n            file_path=node.file_path,\n            docstring=attribute_data[\"docstring\"],\n            attr_type=attribute_data[\"annotation\"],\n            properties=[\"dataclass-field\"],\n        )\n\n    def get_classmethod_documentation(self, node: ObjectNode) -&gt; Method:\n        \"\"\"Get the documentation for a class-method.\n\n        Arguments:\n            node: The node representing the class-method and its parents.\n\n        Returns:\n            The documented method object.\n        \"\"\"\n        return self.get_method_documentation(node, [\"classmethod\"])\n\n    def get_staticmethod_documentation(self, node: ObjectNode) -&gt; Method:\n        \"\"\"Get the documentation for a static-method.\n\n        Arguments:\n            node: The node representing the static-method and its parents.\n\n        Returns:\n            The documented method object.\n        \"\"\"\n        return self.get_method_documentation(node, [\"staticmethod\"])\n\n    def get_regular_method_documentation(self, node: ObjectNode) -&gt; Method:\n        \"\"\"Get the documentation for a regular method (not class- nor static-method).\n\n        We do extra processing in this method to discard docstrings of `__init__` methods\n        that were inherited from parent classes.\n\n        Arguments:\n            node: The node representing the method and its parents.\n\n        Returns:\n            The documented method object.\n        \"\"\"\n        method = self.get_method_documentation(node)\n        if node.parent:\n            class_ = node.parent.obj\n            if RE_SPECIAL.match(node.name):\n                docstring = method.docstring\n                parent_classes = class_.__mro__[1:]\n                for parent_class in parent_classes:\n                    try:\n                        parent_method = getattr(parent_class, node.name)\n                    except AttributeError:\n                        continue\n                    else:\n                        if docstring == inspect.getdoc(parent_method):\n                            method.docstring = \"\"\n                        break\n        return method\n\n    def get_method_documentation(self, node: ObjectNode, properties: Optional[list[str]] = None) -&gt; Method:\n        \"\"\"Get the documentation for a method or method descriptor.\n\n        Arguments:\n            node: The node representing the method and its parents.\n            properties: A list of properties to apply to the method.\n\n        Returns:\n            The documented method object.\n        \"\"\"\n        method = node.obj\n        path = node.dotted_path\n        signature: Optional[inspect.Signature]\n        source: Optional[Source]\n\n        try:\n            source = Source(*inspect.getsourcelines(method))\n        except OSError:\n            source = None\n        except TypeError:\n            source = None\n\n        if node.is_coroutine_function():\n            if properties is None:\n                properties = [\"async\"]\n            else:\n                properties.append(\"async\")\n\n        try:\n            # for \"built-in\" functions, e.g. those implemented in C,\n            # inspect.signature() uses the __text_signature__ attribute, which\n            # provides a limited but still useful amount of signature information.\n            # \"built-in\" functions with no __text_signature__ will\n            # raise a ValueError().\n            signature = inspect.signature(method)\n        except ValueError:\n            signature = None\n\n        return Method(\n            name=node.name,\n            path=path,\n            file_path=node.file_path,\n            docstring=inspect.getdoc(method),\n            signature=signature,\n            properties=properties or [],\n            source=source,\n        )\n\n    @staticmethod\n    def get_attribute_documentation(node: ObjectNode, attribute_data: Optional[dict] = None) -&gt; Attribute:\n        \"\"\"Get the documentation for an attribute.\n\n        Arguments:\n            node: The node representing the method and its parents.\n            attribute_data: Docstring and annotation for this attribute.\n\n        Returns:\n            The documented attribute object.\n        \"\"\"\n        if attribute_data is None:\n            if node.parent_is_class():\n                attribute_data = get_class_attributes(node.parent.obj).get(node.name, {})  # type: ignore[union-attr]\n            else:\n                attribute_data = get_module_attributes(node.root.obj).get(node.name, {})  # type: ignore[union-attr]\n        return Attribute(\n            name=node.name,\n            path=node.dotted_path,\n            file_path=node.file_path,\n            docstring=attribute_data.get(\"docstring\", \"\"),\n            attr_type=attribute_data.get(\"annotation\", None),\n        )\n\n    def select(self, name: str, names: set[str]) -&gt; bool:\n        \"\"\"Tells whether we should select an object or not, given its name.\n\n        If the set of names is not empty, we check against it, otherwise we check against filters.\n\n        Arguments:\n            name: The name of the object to select or not.\n            names: An explicit list of names to select.\n\n        Returns:\n            Yes or no.\n        \"\"\"\n        if names:\n            return name in names\n        return not self.filter_name_out(name)\n\n    @cache  # noqa: B019\n    def filter_name_out(self, name: str) -&gt; bool:\n        \"\"\"Filter a name based on the loader's filters.\n\n        Arguments:\n            name: The name to filter.\n\n        Returns:\n            True if the name was filtered out, False otherwise.\n        \"\"\"\n        if not self.filters:\n            return False\n        keep = True\n        for fltr, regex in self.filters:\n            is_matching = bool(regex.search(name))\n            if is_matching:\n                if str(fltr).startswith(\"!\"):\n                    is_matching = not is_matching\n                keep = is_matching\n        return not keep\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.__init__","title":"<code>__init__(filters=None, docstring_style='google', docstring_options=None, inherited_members=False, new_path_syntax=False)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Optional[list[str]]</code> <p>A list of regular expressions to fine-grain select members. It is applied recursively.</p> <code>None</code> <code>docstring_style</code> <code>str</code> <p>The style to use when parsing docstrings.</p> <code>'google'</code> <code>docstring_options</code> <code>Optional[dict]</code> <p>The options to pass to the docstrings parser.</p> <code>None</code> <code>inherited_members</code> <code>bool</code> <p>Whether to select inherited members for classes.</p> <code>False</code> <code>new_path_syntax</code> <code>bool</code> <p>Whether to use the \"colon\" syntax for the path.</p> <code>False</code> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def __init__(\n    self,\n    filters: Optional[list[str]] = None,\n    docstring_style: str = \"google\",\n    docstring_options: Optional[dict] = None,\n    inherited_members: bool = False,  # noqa: FBT001, FBT002\n    new_path_syntax: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        filters: A list of regular expressions to fine-grain select members. It is applied recursively.\n        docstring_style: The style to use when parsing docstrings.\n        docstring_options: The options to pass to the docstrings parser.\n        inherited_members: Whether to select inherited members for classes.\n        new_path_syntax: Whether to use the \"colon\" syntax for the path.\n    \"\"\"\n    if not filters:\n        filters = []\n\n    self.filters = [(filtr, re.compile(filtr.lstrip(\"!\"))) for filtr in filters]\n    self.docstring_parser = PARSERS[docstring_style](**(docstring_options or {}))\n    self.errors: list[str] = []\n    self.select_inherited_members = inherited_members\n    self.new_path_syntax = new_path_syntax\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.add_fields","title":"<code>add_fields(node, root_object, attr_name, members, select_members, base_class, add_method)</code>","text":"<p>Add detected fields to the current object.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The current object node.</p> required <code>root_object</code> <code>Object</code> <p>The current object.</p> required <code>attr_name</code> <code>str</code> <p>The fields attribute name.</p> required <code>members</code> <code>Mapping[str, Any]</code> <p>The members to pick the fields attribute in.</p> required <code>select_members</code> <code>Optional[Union[set[str], bool]]</code> <p>The members to select.</p> required <code>base_class</code> <code>type</code> <p>The class declaring the fields.</p> required <code>add_method</code> <code>Callable</code> <p>The method to add the children object.</p> required Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def add_fields(\n    self,\n    node: ObjectNode,\n    root_object: Object,\n    attr_name: str,\n    members: Mapping[str, Any],\n    select_members: Optional[Union[set[str], bool]],\n    base_class: type,\n    add_method: Callable,\n) -&gt; None:\n    \"\"\"Add detected fields to the current object.\n\n    Arguments:\n        node: The current object node.\n        root_object: The current object.\n        attr_name: The fields attribute name.\n        members: The members to pick the fields attribute in.\n        select_members: The members to select.\n        base_class: The class declaring the fields.\n        add_method: The method to add the children object.\n    \"\"\"\n    fields = get_fields(attr_name, members=members)\n\n    for field_name, field in fields.items():\n        select_field = self.select(field_name, select_members)  # type: ignore[arg-type]\n        is_inherited = field_is_inherited(field_name, attr_name, base_class)\n\n        if select_field and (self.select_inherited_members or not is_inherited):\n            child_node = ObjectNode(obj=field, name=field_name, parent=node)\n            root_object.add_child(add_method(child_node))\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.detect_field_model","title":"<code>detect_field_model(attr_name, direct_members, all_members)</code>","text":"<p>Detect if an attribute is present in members.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>The name of the attribute to detect, can contain dots.</p> required <code>direct_members</code> <code>Sequence[str]</code> <p>The direct members of the class.</p> required <code>all_members</code> <code>dict</code> <p>All members of the class.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the attribute is present.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def detect_field_model(self, attr_name: str, direct_members: Sequence[str], all_members: dict) -&gt; bool:\n    \"\"\"Detect if an attribute is present in members.\n\n    Arguments:\n        attr_name: The name of the attribute to detect, can contain dots.\n        direct_members: The direct members of the class.\n        all_members: All members of the class.\n\n    Returns:\n        Whether the attribute is present.\n    \"\"\"\n    first_order_attr_name, remainder = split_attr_name(attr_name)\n    if not (\n        first_order_attr_name in direct_members\n        or (self.select_inherited_members and first_order_attr_name in all_members)\n    ):\n        return False\n\n    if remainder:\n        with suppress(AttributeError):\n            return bool(attrgetter(remainder)(all_members[first_order_attr_name]))\n    return True\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.filter_name_out","title":"<code>filter_name_out(name)</code>  <code>cached</code>","text":"<p>Filter a name based on the loader's filters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to filter.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the name was filtered out, False otherwise.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@cache  # noqa: B019\ndef filter_name_out(self, name: str) -&gt; bool:\n    \"\"\"Filter a name based on the loader's filters.\n\n    Arguments:\n        name: The name to filter.\n\n    Returns:\n        True if the name was filtered out, False otherwise.\n    \"\"\"\n    if not self.filters:\n        return False\n    keep = True\n    for fltr, regex in self.filters:\n        is_matching = bool(regex.search(name))\n        if is_matching:\n            if str(fltr).startswith(\"!\"):\n                is_matching = not is_matching\n            keep = is_matching\n    return not keep\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_annotated_dataclass_field","title":"<code>get_annotated_dataclass_field(node, attribute_data=None)</code>  <code>staticmethod</code>","text":"<p>Get the documentation for a dataclass field.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the annotation and its parents.</p> required <code>attribute_data</code> <code>Optional[dict]</code> <p>Docstring and annotation for this attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@staticmethod\ndef get_annotated_dataclass_field(node: ObjectNode, attribute_data: Optional[dict] = None) -&gt; Attribute:\n    \"\"\"Get the documentation for a dataclass field.\n\n    Arguments:\n        node: The node representing the annotation and its parents.\n        attribute_data: Docstring and annotation for this attribute.\n\n    Returns:\n        The documented attribute object.\n    \"\"\"\n    if attribute_data is None:\n        if node.parent_is_class():\n            attribute_data = get_class_attributes(node.parent.obj).get(node.name, {})  # type: ignore[union-attr]\n        else:\n            attribute_data = get_module_attributes(node.root.obj).get(node.name, {})\n\n    return Attribute(\n        name=node.name,\n        path=node.dotted_path,\n        file_path=node.file_path,\n        docstring=attribute_data[\"docstring\"],\n        attr_type=attribute_data[\"annotation\"],\n        properties=[\"dataclass-field\"],\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_attribute_documentation","title":"<code>get_attribute_documentation(node, attribute_data=None)</code>  <code>staticmethod</code>","text":"<p>Get the documentation for an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the method and its parents.</p> required <code>attribute_data</code> <code>Optional[dict]</code> <p>Docstring and annotation for this attribute.</p> <code>None</code> <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@staticmethod\ndef get_attribute_documentation(node: ObjectNode, attribute_data: Optional[dict] = None) -&gt; Attribute:\n    \"\"\"Get the documentation for an attribute.\n\n    Arguments:\n        node: The node representing the method and its parents.\n        attribute_data: Docstring and annotation for this attribute.\n\n    Returns:\n        The documented attribute object.\n    \"\"\"\n    if attribute_data is None:\n        if node.parent_is_class():\n            attribute_data = get_class_attributes(node.parent.obj).get(node.name, {})  # type: ignore[union-attr]\n        else:\n            attribute_data = get_module_attributes(node.root.obj).get(node.name, {})  # type: ignore[union-attr]\n    return Attribute(\n        name=node.name,\n        path=node.dotted_path,\n        file_path=node.file_path,\n        docstring=attribute_data.get(\"docstring\", \"\"),\n        attr_type=attribute_data.get(\"annotation\", None),\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_class_documentation","title":"<code>get_class_documentation(node, select_members=None)</code>","text":"<p>Get the documentation for a class and its children.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the class and its parents.</p> required <code>select_members</code> <code>Optional[Union[set[str], bool]]</code> <p>Explicit members to select.</p> <code>None</code> <p>Returns:</p> Type Description <code>Class</code> <p>The documented class object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_class_documentation(\n    self,\n    node: ObjectNode,\n    select_members: Optional[Union[set[str], bool]] = None,\n) -&gt; Class:\n    \"\"\"Get the documentation for a class and its children.\n\n    Arguments:\n        node: The node representing the class and its parents.\n        select_members: Explicit members to select.\n\n    Returns:\n        The documented class object.\n    \"\"\"\n    class_ = node.obj\n    docstring = inspect.cleandoc(class_.__doc__ or \"\")\n    bases = [self._class_path(b) for b in class_.__bases__]\n\n    source: Optional[Source]\n\n    try:\n        source = Source(*inspect.getsourcelines(node.obj))\n    except (OSError, TypeError):\n        source = None\n\n    root_object = Class(\n        name=node.name,\n        path=node.dotted_path,\n        file_path=node.file_path,\n        docstring=docstring,\n        bases=bases,\n        source=source,\n    )\n\n    # Even if we don't select members, we want to correctly parse the docstring\n    attributes_data: dict[str, dict[str, Any]] = {}\n    for parent_class in reversed(class_.__mro__[:-1]):\n        merge(attributes_data, get_class_attributes(parent_class))\n    context: dict[str, Any] = {\"attributes\": attributes_data}\n    if \"__init__\" in class_.__dict__:\n        try:\n            attributes_data.update(get_instance_attributes(class_.__init__))\n            context[\"signature\"] = inspect.signature(class_.__init__)\n        except (TypeError, ValueError):\n            pass\n    root_object.parse_docstring(self.docstring_parser, **context)\n\n    if select_members is False:\n        return root_object\n\n    select_members = select_members or set()\n\n    # Build the list of members\n    members = {}\n    inherited = set()\n    direct_members = class_.__dict__\n    all_members = dict(inspect.getmembers(class_))\n    for member_name, member in all_members.items():\n        if member is class_:\n            continue\n        if not (member is type or member is object) and self.select(member_name, select_members):  # type: ignore[arg-type]\n            if member_name not in direct_members:\n                if self.select_inherited_members:\n                    members[member_name] = member\n                    inherited.add(member_name)\n            else:\n                members[member_name] = member\n\n    # Iterate on the selected members\n    child: Object\n    for member_name, member in members.items():\n        child_node = ObjectNode(member, member_name, parent=node)\n        if child_node.is_class():\n            child = self.get_class_documentation(child_node)\n        elif child_node.is_classmethod():\n            child = self.get_classmethod_documentation(child_node)\n        elif child_node.is_staticmethod():\n            child = self.get_staticmethod_documentation(child_node)\n        elif child_node.is_method():\n            child = self.get_regular_method_documentation(child_node)\n        elif child_node.is_property():\n            child = self.get_property_documentation(child_node)\n        elif member_name in attributes_data:\n            child = self.get_attribute_documentation(child_node, attributes_data[member_name])\n        else:\n            continue\n        if member_name in inherited:\n            child.properties.append(\"inherited\")\n        root_object.add_child(child)\n\n    for attr_name, properties, add_method in (\n        (\"__fields__\", [\"pydantic-model\"], self.get_pydantic_field_documentation),\n        (\"_declared_fields\", [\"marshmallow-model\"], self.get_marshmallow_field_documentation),\n        (\"_meta.get_fields\", [\"django-model\"], self.get_django_field_documentation),\n        (\"__dataclass_fields__\", [\"dataclass\"], self.get_annotated_dataclass_field),\n    ):\n        if self.detect_field_model(attr_name, direct_members, all_members):\n            root_object.properties.extend(properties)\n            self.add_fields(\n                node,\n                root_object,\n                attr_name,\n                all_members,\n                select_members,\n                class_,\n                add_method,\n            )\n            break\n\n    return root_object\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_classmethod_documentation","title":"<code>get_classmethod_documentation(node)</code>","text":"<p>Get the documentation for a class-method.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the class-method and its parents.</p> required <p>Returns:</p> Type Description <code>Method</code> <p>The documented method object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_classmethod_documentation(self, node: ObjectNode) -&gt; Method:\n    \"\"\"Get the documentation for a class-method.\n\n    Arguments:\n        node: The node representing the class-method and its parents.\n\n    Returns:\n        The documented method object.\n    \"\"\"\n    return self.get_method_documentation(node, [\"classmethod\"])\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_django_field_documentation","title":"<code>get_django_field_documentation(node)</code>  <code>staticmethod</code>","text":"<p>Get the documentation for a Django Field.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the Field and its parents.</p> required <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@staticmethod\ndef get_django_field_documentation(node: ObjectNode) -&gt; Attribute:\n    \"\"\"Get the documentation for a Django Field.\n\n    Arguments:\n        node: The node representing the Field and its parents.\n\n    Returns:\n        The documented attribute object.\n    \"\"\"\n    prop = node.obj\n    path = node.dotted_path\n    properties = [\"django-field\"]\n\n    if prop.null:\n        properties.append(\"nullable\")\n    if prop.blank:\n        properties.append(\"blank\")\n\n    # set correct docstring based on verbose_name and help_text\n    # both should be converted to str type in case lazy translation\n    # is being used, which is common scenario in django\n    docstring = f\"{prop.verbose_name}: {prop.help_text}\" if prop.help_text else str(prop.verbose_name)\n\n    return Attribute(\n        name=node.name,\n        path=path,\n        file_path=node.file_path,\n        docstring=docstring,\n        attr_type=prop.__class__,\n        properties=properties,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_function_documentation","title":"<code>get_function_documentation(node)</code>","text":"<p>Get the documentation for a function.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the function and its parents.</p> required <p>Returns:</p> Type Description <code>Function</code> <p>The documented function object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_function_documentation(self, node: ObjectNode) -&gt; Function:\n    \"\"\"Get the documentation for a function.\n\n    Arguments:\n        node: The node representing the function and its parents.\n\n    Returns:\n        The documented function object.\n    \"\"\"\n    function = node.obj\n    source: Optional[Source]\n    signature: Optional[inspect.Signature]\n\n    try:\n        signature = inspect.signature(function)\n    except TypeError:\n        signature = None\n\n    try:\n        source = Source(*inspect.getsourcelines(function))\n    except OSError:\n        source = None\n\n    properties: list[str] = []\n    if node.is_coroutine_function():\n        properties.append(\"async\")\n\n    return Function(\n        name=node.name,\n        path=node.dotted_path,\n        file_path=node.file_path,\n        docstring=inspect.getdoc(function),\n        signature=signature,\n        source=source,\n        properties=properties,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_marshmallow_field_documentation","title":"<code>get_marshmallow_field_documentation(node)</code>  <code>staticmethod</code>","text":"<p>Get the documentation for a Marshmallow Field.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the Field and its parents.</p> required <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@staticmethod\ndef get_marshmallow_field_documentation(node: ObjectNode) -&gt; Attribute:\n    \"\"\"Get the documentation for a Marshmallow Field.\n\n    Arguments:\n        node: The node representing the Field and its parents.\n\n    Returns:\n        The documented attribute object.\n    \"\"\"\n    prop = node.obj\n    path = node.dotted_path\n    properties = [\"marshmallow-field\"]\n    if prop.required:\n        properties.append(\"required\")\n\n    return Attribute(\n        name=node.name,\n        path=path,\n        file_path=node.file_path,\n        docstring=prop.metadata.get(\"description\"),\n        attr_type=type(prop),\n        properties=properties,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_method_documentation","title":"<code>get_method_documentation(node, properties=None)</code>","text":"<p>Get the documentation for a method or method descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the method and its parents.</p> required <code>properties</code> <code>Optional[list[str]]</code> <p>A list of properties to apply to the method.</p> <code>None</code> <p>Returns:</p> Type Description <code>Method</code> <p>The documented method object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_method_documentation(self, node: ObjectNode, properties: Optional[list[str]] = None) -&gt; Method:\n    \"\"\"Get the documentation for a method or method descriptor.\n\n    Arguments:\n        node: The node representing the method and its parents.\n        properties: A list of properties to apply to the method.\n\n    Returns:\n        The documented method object.\n    \"\"\"\n    method = node.obj\n    path = node.dotted_path\n    signature: Optional[inspect.Signature]\n    source: Optional[Source]\n\n    try:\n        source = Source(*inspect.getsourcelines(method))\n    except OSError:\n        source = None\n    except TypeError:\n        source = None\n\n    if node.is_coroutine_function():\n        if properties is None:\n            properties = [\"async\"]\n        else:\n            properties.append(\"async\")\n\n    try:\n        # for \"built-in\" functions, e.g. those implemented in C,\n        # inspect.signature() uses the __text_signature__ attribute, which\n        # provides a limited but still useful amount of signature information.\n        # \"built-in\" functions with no __text_signature__ will\n        # raise a ValueError().\n        signature = inspect.signature(method)\n    except ValueError:\n        signature = None\n\n    return Method(\n        name=node.name,\n        path=path,\n        file_path=node.file_path,\n        docstring=inspect.getdoc(method),\n        signature=signature,\n        properties=properties or [],\n        source=source,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_module_documentation","title":"<code>get_module_documentation(node, select_members=None)</code>","text":"<p>Get the documentation for a module and its children.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the module and its parents.</p> required <code>select_members</code> <code>Optional[Union[set[str], bool]]</code> <p>Explicit members to select.</p> <code>None</code> <p>Returns:</p> Type Description <code>Module</code> <p>The documented module object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_module_documentation(\n    self,\n    node: ObjectNode,\n    select_members: Optional[Union[set[str], bool]] = None,\n) -&gt; Module:\n    \"\"\"Get the documentation for a module and its children.\n\n    Arguments:\n        node: The node representing the module and its parents.\n        select_members: Explicit members to select.\n\n    Returns:\n        The documented module object.\n    \"\"\"\n    module = node.obj\n    path = node.dotted_path\n    name = path.split(\".\")[-1]\n    source: Optional[Source]\n\n    try:\n        source = Source(inspect.getsource(module), 1)\n    except OSError:\n        try:\n            code = Path(node.file_path).read_text()\n        except (OSError, UnicodeDecodeError):\n            source = None\n        else:\n            source = Source(code, 1) if code else None\n\n    root_object = Module(\n        name=name,\n        path=path,\n        file_path=node.file_path,\n        docstring=inspect.getdoc(module),\n        source=source,\n    )\n\n    if select_members is False:\n        return root_object\n\n    select_members = select_members or set()\n\n    attributes_data = get_module_attributes(module)\n    root_object.parse_docstring(self.docstring_parser, attributes=attributes_data)\n\n    for member_name, member in inspect.getmembers(module):\n        if self.select(member_name, select_members):  # type: ignore[arg-type]\n            child_node = ObjectNode(member, member_name, parent=node)\n            if child_node.is_class() and node.root.obj is inspect.getmodule(child_node.obj):\n                root_object.add_child(self.get_class_documentation(child_node))\n            elif child_node.is_function() and node.root.obj is inspect.getmodule(child_node.obj):\n                root_object.add_child(self.get_function_documentation(child_node))\n            elif member_name in attributes_data:\n                root_object.add_child(self.get_attribute_documentation(child_node, attributes_data[member_name]))\n\n    if hasattr(module, \"__path__\"):\n        for _, modname, _ in pkgutil.iter_modules(module.__path__):\n            if self.select(modname, select_members):  # type: ignore[arg-type]\n                leaf = get_object_tree(f\"{path}.{modname}\")\n                root_object.add_child(self.get_module_documentation(leaf))\n\n    return root_object\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_object_documentation","title":"<code>get_object_documentation(dotted_path, members=None)</code>","text":"<p>Get the documentation for an object and its children.</p> <p>Parameters:</p> Name Type Description Default <code>dotted_path</code> <code>str</code> <p>The Python dotted path to the desired object.</p> required <code>members</code> <code>Optional[Union[set[str], bool]]</code> <p><code>True</code> to select members and filter them, <code>False</code> to select no members, or a list of names to explicitly select the members with these names. It is applied only on the root object.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The documented object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_object_documentation(self, dotted_path: str, members: Optional[Union[set[str], bool]] = None) -&gt; Object:\n    \"\"\"Get the documentation for an object and its children.\n\n    Arguments:\n        dotted_path: The Python dotted path to the desired object.\n        members: `True` to select members and filter them, `False` to select no members,\n            or a list of names to explicitly select the members with these names.\n            It is applied only on the root object.\n\n    Returns:\n        The documented object.\n    \"\"\"\n    if members is True:\n        members = set()\n\n    root_object: Object\n    leaf = get_object_tree(dotted_path, self.new_path_syntax)\n\n    if leaf.is_module():\n        root_object = self.get_module_documentation(leaf, members)\n    elif leaf.is_class():\n        root_object = self.get_class_documentation(leaf, members)\n    elif leaf.is_staticmethod():\n        root_object = self.get_staticmethod_documentation(leaf)\n    elif leaf.is_classmethod():\n        root_object = self.get_classmethod_documentation(leaf)\n    elif leaf.is_method_descriptor() or leaf.is_method():\n        root_object = self.get_regular_method_documentation(leaf)\n    elif leaf.is_function():\n        root_object = self.get_function_documentation(leaf)\n    elif leaf.is_property():\n        root_object = self.get_property_documentation(leaf)\n    else:\n        root_object = self.get_attribute_documentation(leaf)\n\n    root_object.parse_all_docstrings(self.docstring_parser)\n\n    return root_object\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_property_documentation","title":"<code>get_property_documentation(node)</code>","text":"<p>Get the documentation for a property.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the property and its parents.</p> required <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object (properties are considered attributes for now).</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_property_documentation(self, node: ObjectNode) -&gt; Attribute:\n    \"\"\"Get the documentation for a property.\n\n    Arguments:\n        node: The node representing the property and its parents.\n\n    Returns:\n        The documented attribute object (properties are considered attributes for now).\n    \"\"\"\n    prop = node.obj\n    path = node.dotted_path\n    properties = [\"property\"]\n    if node.is_cached_property():\n        # cached_property is always writable, see the docs\n        properties.extend([\"writable\", \"cached\"])\n        sig_source_func = prop.func\n    else:\n        properties.append(\"readonly\" if prop.fset is None else \"writable\")\n        sig_source_func = prop.fget\n\n    source: Optional[Source]\n\n    try:\n        signature = inspect.signature(sig_source_func)\n    except (TypeError, ValueError):\n        attr_type = None\n    else:\n        attr_type = signature.return_annotation\n\n    try:\n        source = Source(*inspect.getsourcelines(sig_source_func))\n    except (OSError, TypeError):\n        source = None\n\n    return Attribute(\n        name=node.name,\n        path=path,\n        file_path=node.file_path,\n        docstring=inspect.getdoc(prop),\n        attr_type=attr_type,\n        properties=properties,\n        source=source,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_pydantic_field_documentation","title":"<code>get_pydantic_field_documentation(node)</code>  <code>staticmethod</code>","text":"<p>Get the documentation for a Pydantic Field.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the Field and its parents.</p> required <p>Returns:</p> Type Description <code>Attribute</code> <p>The documented attribute object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>@staticmethod\ndef get_pydantic_field_documentation(node: ObjectNode) -&gt; Attribute:\n    \"\"\"Get the documentation for a Pydantic Field.\n\n    Arguments:\n        node: The node representing the Field and its parents.\n\n    Returns:\n        The documented attribute object.\n    \"\"\"\n    prop = node.obj\n    path = node.dotted_path\n    properties = [\"pydantic-field\"]\n    if prop.required:\n        properties.append(\"required\")\n\n    return Attribute(\n        name=node.name,\n        path=path,\n        file_path=node.file_path,\n        docstring=prop.field_info.description,\n        attr_type=prop.outer_type_,\n        properties=properties,\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_regular_method_documentation","title":"<code>get_regular_method_documentation(node)</code>","text":"<p>Get the documentation for a regular method (not class- nor static-method).</p> <p>We do extra processing in this method to discard docstrings of <code>__init__</code> methods that were inherited from parent classes.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the method and its parents.</p> required <p>Returns:</p> Type Description <code>Method</code> <p>The documented method object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_regular_method_documentation(self, node: ObjectNode) -&gt; Method:\n    \"\"\"Get the documentation for a regular method (not class- nor static-method).\n\n    We do extra processing in this method to discard docstrings of `__init__` methods\n    that were inherited from parent classes.\n\n    Arguments:\n        node: The node representing the method and its parents.\n\n    Returns:\n        The documented method object.\n    \"\"\"\n    method = self.get_method_documentation(node)\n    if node.parent:\n        class_ = node.parent.obj\n        if RE_SPECIAL.match(node.name):\n            docstring = method.docstring\n            parent_classes = class_.__mro__[1:]\n            for parent_class in parent_classes:\n                try:\n                    parent_method = getattr(parent_class, node.name)\n                except AttributeError:\n                    continue\n                else:\n                    if docstring == inspect.getdoc(parent_method):\n                        method.docstring = \"\"\n                    break\n    return method\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.get_staticmethod_documentation","title":"<code>get_staticmethod_documentation(node)</code>","text":"<p>Get the documentation for a static-method.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ObjectNode</code> <p>The node representing the static-method and its parents.</p> required <p>Returns:</p> Type Description <code>Method</code> <p>The documented method object.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_staticmethod_documentation(self, node: ObjectNode) -&gt; Method:\n    \"\"\"Get the documentation for a static-method.\n\n    Arguments:\n        node: The node representing the static-method and its parents.\n\n    Returns:\n        The documented method object.\n    \"\"\"\n    return self.get_method_documentation(node, [\"staticmethod\"])\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.Loader.select","title":"<code>select(name, names)</code>","text":"<p>Tells whether we should select an object or not, given its name.</p> <p>If the set of names is not empty, we check against it, otherwise we check against filters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object to select or not.</p> required <code>names</code> <code>set[str]</code> <p>An explicit list of names to select.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Yes or no.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def select(self, name: str, names: set[str]) -&gt; bool:\n    \"\"\"Tells whether we should select an object or not, given its name.\n\n    If the set of names is not empty, we check against it, otherwise we check against filters.\n\n    Arguments:\n        name: The name of the object to select or not.\n        names: An explicit list of names to select.\n\n    Returns:\n        Yes or no.\n    \"\"\"\n    if names:\n        return name in names\n    return not self.filter_name_out(name)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode","title":"<code>ObjectNode</code>","text":"<p>Helper class to represent an object tree.</p> <p>It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).</p> <p>Each node stores an object, its name, and a reference to its parent node.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>class ObjectNode:\n    \"\"\"Helper class to represent an object tree.\n\n    It's not really a tree but more a backward-linked list:\n    each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).\n\n    Each node stores an object, its name, and a reference to its parent node.\n    \"\"\"\n\n    def __init__(self, obj: Any, name: str, parent: Optional[\"ObjectNode\"] = None) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            obj: A Python object.\n            name: The object's name.\n            parent: The object's parent node.\n        \"\"\"\n        try:  # noqa: SIM105\n            obj = inspect.unwrap(obj)\n        except Exception:  # noqa: S110 , BLE001  (we purposely catch every possible exception)\n            # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"),\n            # which triggers the __getattr__ method of the object, which in\n            # turn can raise various exceptions. Probably not just __getattr__.\n            # See https://github.com/pawamoy/pytkdocs/issues/45\n            pass\n\n        self.obj: Any = obj\n        \"\"\"The actual Python object.\"\"\"\n\n        self.name: str = name\n        \"\"\"The Python object's name.\"\"\"\n\n        self.parent: Optional[ObjectNode] = parent\n        \"\"\"The parent node.\"\"\"\n\n    @property\n    def dotted_path(self) -&gt; str:\n        \"\"\"Return the Python dotted path to the object.\n\n        Returns:\n            The Python dotted path to the object.\n        \"\"\"\n        parts = [self.name]\n        current = self.parent\n        while current:\n            parts.append(current.name)\n            current = current.parent\n        return \".\".join(reversed(parts))\n\n    @property\n    def file_path(self) -&gt; str:\n        \"\"\"Return the object's module file path.\n\n        Returns:\n            The object's module file path.\n        \"\"\"\n        return inspect.getabsfile(self.root.obj)\n\n    @property\n    def root(self) -&gt; \"ObjectNode\":\n        \"\"\"Return the root of the tree.\n\n        Returns:\n            The root of the tree.\n        \"\"\"\n        if self.parent is not None:\n            return self.parent.root\n        return self\n\n    def is_module(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a module.\n\n        Returns:\n            The root of the tree.\n        \"\"\"\n        return inspect.ismodule(self.obj)\n\n    def is_class(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a class.\n\n        Returns:\n            If this node's object is a class.\n        \"\"\"\n        return inspect.isclass(self.obj)\n\n    def is_function(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a function.\n\n        Returns:\n            If this node's object is a function.\n        \"\"\"\n        return inspect.isfunction(self.obj)\n\n    def is_coroutine_function(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a coroutine.\n\n        Returns:\n            If this node's object is a coroutine.\n        \"\"\"\n        return inspect.iscoroutinefunction(self.obj)\n\n    def is_property(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a property.\n\n        Returns:\n            If this node's object is a property.\n        \"\"\"\n        return isinstance(self.obj, property) or self.is_cached_property()\n\n    def is_cached_property(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a cached property.\n\n        Returns:\n            If this node's object is a cached property.\n        \"\"\"\n        return isinstance(self.obj, cached_property)\n\n    def parent_is_class(self) -&gt; bool:\n        \"\"\"Tell if the object of this node's parent is a class.\n\n        Returns:\n            If the object of this node's parent is a class.\n        \"\"\"\n        return bool(self.parent and self.parent.is_class())\n\n    def is_method(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a method.\n\n        Returns:\n            If this node's object is a method.\n        \"\"\"\n        function_type = type(lambda: None)\n        return self.parent_is_class() and isinstance(self.obj, function_type)\n\n    def is_method_descriptor(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a method descriptor.\n\n        Built-in methods (e.g. those implemented in C/Rust) are often\n        method descriptors, rather than normal methods.\n\n        Returns:\n            If this node's object is a method descriptor.\n        \"\"\"\n        return inspect.ismethoddescriptor(self.obj)\n\n    def is_staticmethod(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a staticmethod.\n\n        Returns:\n            If this node's object is a staticmethod.\n        \"\"\"\n        if not self.parent:\n            return False\n        self_from_parent = self.parent.obj.__dict__.get(self.name, None)\n        return self.parent_is_class() and isinstance(self_from_parent, staticmethod)\n\n    def is_classmethod(self) -&gt; bool:\n        \"\"\"Tell if this node's object is a classmethod.\n\n        Returns:\n            If this node's object is a classmethod.\n        \"\"\"\n        if not self.parent:\n            return False\n        self_from_parent = self.parent.obj.__dict__.get(self.name, None)\n        return self.parent_is_class() and isinstance(self_from_parent, classmethod)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.dotted_path","title":"<code>dotted_path</code>  <code>property</code>","text":"<p>Return the Python dotted path to the object.</p> <p>Returns:</p> Type Description <code>str</code> <p>The Python dotted path to the object.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.file_path","title":"<code>file_path</code>  <code>property</code>","text":"<p>Return the object's module file path.</p> <p>Returns:</p> Type Description <code>str</code> <p>The object's module file path.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":"<p>The Python object's name.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":"<p>The actual Python object.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.parent","title":"<code>parent = parent</code>  <code>instance-attribute</code>","text":"<p>The parent node.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return the root of the tree.</p> <p>Returns:</p> Type Description <code>ObjectNode</code> <p>The root of the tree.</p>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.__init__","title":"<code>__init__(obj, name, parent=None)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>A Python object.</p> required <code>name</code> <code>str</code> <p>The object's name.</p> required <code>parent</code> <code>Optional[ObjectNode]</code> <p>The object's parent node.</p> <code>None</code> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def __init__(self, obj: Any, name: str, parent: Optional[\"ObjectNode\"] = None) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        obj: A Python object.\n        name: The object's name.\n        parent: The object's parent node.\n    \"\"\"\n    try:  # noqa: SIM105\n        obj = inspect.unwrap(obj)\n    except Exception:  # noqa: S110 , BLE001  (we purposely catch every possible exception)\n        # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"),\n        # which triggers the __getattr__ method of the object, which in\n        # turn can raise various exceptions. Probably not just __getattr__.\n        # See https://github.com/pawamoy/pytkdocs/issues/45\n        pass\n\n    self.obj: Any = obj\n    \"\"\"The actual Python object.\"\"\"\n\n    self.name: str = name\n    \"\"\"The Python object's name.\"\"\"\n\n    self.parent: Optional[ObjectNode] = parent\n    \"\"\"The parent node.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_cached_property","title":"<code>is_cached_property()</code>","text":"<p>Tell if this node's object is a cached property.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a cached property.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_cached_property(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a cached property.\n\n    Returns:\n        If this node's object is a cached property.\n    \"\"\"\n    return isinstance(self.obj, cached_property)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_class","title":"<code>is_class()</code>","text":"<p>Tell if this node's object is a class.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a class.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_class(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a class.\n\n    Returns:\n        If this node's object is a class.\n    \"\"\"\n    return inspect.isclass(self.obj)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_classmethod","title":"<code>is_classmethod()</code>","text":"<p>Tell if this node's object is a classmethod.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a classmethod.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_classmethod(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a classmethod.\n\n    Returns:\n        If this node's object is a classmethod.\n    \"\"\"\n    if not self.parent:\n        return False\n    self_from_parent = self.parent.obj.__dict__.get(self.name, None)\n    return self.parent_is_class() and isinstance(self_from_parent, classmethod)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_coroutine_function","title":"<code>is_coroutine_function()</code>","text":"<p>Tell if this node's object is a coroutine.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a coroutine.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_coroutine_function(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a coroutine.\n\n    Returns:\n        If this node's object is a coroutine.\n    \"\"\"\n    return inspect.iscoroutinefunction(self.obj)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_function","title":"<code>is_function()</code>","text":"<p>Tell if this node's object is a function.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a function.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_function(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a function.\n\n    Returns:\n        If this node's object is a function.\n    \"\"\"\n    return inspect.isfunction(self.obj)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_method","title":"<code>is_method()</code>","text":"<p>Tell if this node's object is a method.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a method.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_method(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a method.\n\n    Returns:\n        If this node's object is a method.\n    \"\"\"\n    function_type = type(lambda: None)\n    return self.parent_is_class() and isinstance(self.obj, function_type)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_method_descriptor","title":"<code>is_method_descriptor()</code>","text":"<p>Tell if this node's object is a method descriptor.</p> <p>Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a method descriptor.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_method_descriptor(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a method descriptor.\n\n    Built-in methods (e.g. those implemented in C/Rust) are often\n    method descriptors, rather than normal methods.\n\n    Returns:\n        If this node's object is a method descriptor.\n    \"\"\"\n    return inspect.ismethoddescriptor(self.obj)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_module","title":"<code>is_module()</code>","text":"<p>Tell if this node's object is a module.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The root of the tree.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_module(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a module.\n\n    Returns:\n        The root of the tree.\n    \"\"\"\n    return inspect.ismodule(self.obj)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_property","title":"<code>is_property()</code>","text":"<p>Tell if this node's object is a property.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a property.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_property(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a property.\n\n    Returns:\n        If this node's object is a property.\n    \"\"\"\n    return isinstance(self.obj, property) or self.is_cached_property()\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.is_staticmethod","title":"<code>is_staticmethod()</code>","text":"<p>Tell if this node's object is a staticmethod.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If this node's object is a staticmethod.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def is_staticmethod(self) -&gt; bool:\n    \"\"\"Tell if this node's object is a staticmethod.\n\n    Returns:\n        If this node's object is a staticmethod.\n    \"\"\"\n    if not self.parent:\n        return False\n    self_from_parent = self.parent.obj.__dict__.get(self.name, None)\n    return self.parent_is_class() and isinstance(self_from_parent, staticmethod)\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.ObjectNode.parent_is_class","title":"<code>parent_is_class()</code>","text":"<p>Tell if the object of this node's parent is a class.</p> <p>Returns:</p> Type Description <code>bool</code> <p>If the object of this node's parent is a class.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def parent_is_class(self) -&gt; bool:\n    \"\"\"Tell if the object of this node's parent is a class.\n\n    Returns:\n        If the object of this node's parent is a class.\n    \"\"\"\n    return bool(self.parent and self.parent.is_class())\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.field_is_inherited","title":"<code>field_is_inherited(field_name, fields_name, base_class)</code>","text":"<p>Check if a field with a certain name was inherited from parent classes.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the field to check.</p> required <code>fields_name</code> <code>str</code> <p>The name of the attribute in which the fields are stored.</p> required <code>base_class</code> <code>type</code> <p>The base class in which the field appears.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field was inherited.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def field_is_inherited(field_name: str, fields_name: str, base_class: type) -&gt; bool:\n    \"\"\"Check if a field with a certain name was inherited from parent classes.\n\n    Arguments:\n        field_name: The name of the field to check.\n        fields_name: The name of the attribute in which the fields are stored.\n        base_class: The base class in which the field appears.\n\n    Returns:\n        Whether the field was inherited.\n    \"\"\"\n    # To tell if a field was inherited, we check if it exists in parent classes __fields__ attributes.\n    # We don't check the current class, nor the top one (object), hence __mro__[1:-1]\n    return field_name in set(\n        chain(\n            *(getattr(parent_class, fields_name, {}).keys() for parent_class in base_class.__mro__[1:-1]),\n        ),\n    )\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.get_object_tree","title":"<code>get_object_tree(path, new_path_syntax=False)</code>","text":"<p>Transform a path into an actual Python object.</p> <p>The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through <code>importlib.import_module</code> and each object is obtainable through the <code>getattr</code> method. It is not possible to load local objects.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The dot/colon-separated path of the object.</p> required <code>new_path_syntax</code> <code>bool</code> <p>Whether to use the \"colon\" syntax for the path.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the path is not valid (evaluates to <code>False</code>).</p> <code>ImportError</code> <p>When the object or its parent module could not be imported.</p> <p>Returns:</p> Type Description <code>ObjectNode</code> <p>The leaf node representing the object and its parents.</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def get_object_tree(path: str, new_path_syntax: bool = False) -&gt; ObjectNode:  # noqa: FBT001, FBT002\n    \"\"\"Transform a path into an actual Python object.\n\n    The path can be arbitrary long. You can pass the path to a package,\n    a module, a class, a function or a global variable, as deep as you\n    want, as long as the deepest module is importable through\n    `importlib.import_module` and each object is obtainable through\n    the `getattr` method. It is not possible to load local objects.\n\n    Args:\n        path: The dot/colon-separated path of the object.\n        new_path_syntax: Whether to use the \"colon\" syntax for the path.\n\n    Raises:\n        ValueError: When the path is not valid (evaluates to `False`).\n        ImportError: When the object or its parent module could not be imported.\n\n    Returns:\n        The leaf node representing the object and its parents.\n    \"\"\"\n    if not path:\n        raise ValueError(f\"path must be a valid Python path, not {path}\")\n\n    objects: list[str] = []\n\n    if \":\" in path or new_path_syntax:\n        try:\n            module_path, object_path = path.split(\":\")\n        except ValueError:  # no colon\n            module_path, objects = path, []\n        else:\n            objects = object_path.split(\".\")\n\n        # let the ImportError bubble up\n        parent_module = importlib.import_module(module_path)\n\n    else:\n        # We will try to import the longest dotted-path first.\n        # If it fails, we remove the right-most part and put it in a list of \"objects\", used later.\n        # We loop until we find the deepest importable submodule.\n        obj_parent_modules = path.split(\".\")\n\n        while True:\n            parent_module_path = \".\".join(obj_parent_modules)\n            try:\n                parent_module = importlib.import_module(parent_module_path)\n            except ImportError as error:\n                if len(obj_parent_modules) == 1:\n                    raise ImportError(\n                        f\"Importing '{path}' failed, possible causes are:\\n\"\n                        f\"- an exception happened while importing\\n\"\n                        f\"- an element in the path does not exist\",\n                    ) from error\n                objects.insert(0, obj_parent_modules.pop(-1))\n            else:\n                break\n\n    # We now have the module containing the desired object.\n    # We will build the object tree by iterating over the previously stored objects names\n    # and trying to get them as attributes.\n    current_node = ObjectNode(parent_module, parent_module.__name__)\n    for obj_name in objects:\n        obj = getattr(current_node.obj, obj_name)\n        child = ObjectNode(obj, obj_name, parent=current_node)\n        current_node = child\n\n    leaf = current_node\n\n    # We now try to get the \"real\" parent module, not the one the object was imported into.\n    # This is important if we want to be able to retrieve the docstring of an attribute for example.\n    # Once we find an object for which we could get the module, we stop trying to get the module.\n    # Once we reach the node before the root, we apply the module if found, and break.\n    real_module = None\n    while current_node.parent is not None:\n        if real_module is None:\n            real_module = inspect.getmodule(current_node.obj)\n        if inspect.ismodule(current_node.parent.obj):\n            if real_module is not None and real_module is not current_node.parent.obj:\n                current_node.parent = ObjectNode(real_module, real_module.__name__)\n            break\n        current_node = current_node.parent\n\n    return leaf\n</code></pre>"},{"location":"reference/pytkdocs/loader/#pytkdocs.loader.split_attr_name","title":"<code>split_attr_name(attr_name)</code>","text":"<p>Split an attribute name into a first-order attribute name and remainder.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Attribute name (a)</p> required <p>Returns:</p> Type Description <code>tuple[str, Optional[str]]</code> <p>Tuple containing: first_order_attr_name: Name of the first order attribute (a) remainder: The remainder (b.c)</p> Source code in <code>src/pytkdocs/loader.py</code> <pre><code>def split_attr_name(attr_name: str) -&gt; tuple[str, Optional[str]]:\n    \"\"\"Split an attribute name into a first-order attribute name and remainder.\n\n    Args:\n        attr_name: Attribute name (a)\n\n    Returns:\n        Tuple containing:\n            first_order_attr_name: Name of the first order attribute (a)\n            remainder: The remainder (b.c)\n\n    \"\"\"\n    first_order_attr_name, *remaining = attr_name.split(\".\", maxsplit=1)\n    remainder = remaining[0] if remaining else None\n    return first_order_attr_name, remainder\n</code></pre>"},{"location":"reference/pytkdocs/objects/","title":"pytkdocs.objects","text":"<p>This module defines the documented objects classes.</p> <ul> <li>the generic <code>Object</code> class</li> <li>the <code>Module</code> class</li> <li>the <code>Class</code> class</li> <li>the <code>Method</code> class</li> <li>the <code>Function</code> class</li> <li>the <code>Attribute</code> class</li> </ul> <p>Note that properties are considered attributes, because they are used like such.</p> <p>It also defines a convenient <code>Source</code> class to represent source code.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>Object</code></p> <p>A class to store information about an attribute.</p> <p>It accepts an additional <code>attr_type</code> argument at instantiation.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Attribute(Object):\n    \"\"\"A class to store information about an attribute.\n\n    It accepts an additional `attr_type` argument at instantiation.\n    \"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = [NAME_SPECIAL, NAME_CLASS_PRIVATE, NAME_PRIVATE]  # noqa: RUF012\n\n    def __init__(self, *args: Any, attr_type: Optional[Any] = None, **kwargs: Any):\n        \"\"\"Initialize the object.\n\n        Arguments:\n            *args: Arguments passed to the parent class Initialize the object.\n            attr_type: The attribute type.\n            **kwargs: Arguments passed to the parent class Initialize the object.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.type = attr_type\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Attribute.__init__","title":"<code>__init__(*args, attr_type=None, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>()</code> <code>attr_type</code> <code>Optional[Any]</code> <p>The attribute type.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>{}</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(self, *args: Any, attr_type: Optional[Any] = None, **kwargs: Any):\n    \"\"\"Initialize the object.\n\n    Arguments:\n        *args: Arguments passed to the parent class Initialize the object.\n        attr_type: The attribute type.\n        **kwargs: Arguments passed to the parent class Initialize the object.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.type = attr_type\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Class","title":"<code>Class</code>","text":"<p>               Bases: <code>Object</code></p> <p>A class to store information about a class.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Class(Object):\n    \"\"\"A class to store information about a class.\"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = [NAME_PRIVATE]  # noqa: RUF012\n\n    def __init__(self, *args: Any, bases: Optional[list[str]] = None, **kwargs: Any):\n        \"\"\"Initialize the object.\n\n        Arguments:\n            *args: Arguments passed to the parent class Initialize the object.\n            bases: The base classes (dotted paths).\n            **kwargs: Arguments passed to the parent class Initialize the object.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.bases = bases or [\"object\"]\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Class.__init__","title":"<code>__init__(*args, bases=None, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>()</code> <code>bases</code> <code>Optional[list[str]]</code> <p>The base classes (dotted paths).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>{}</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(self, *args: Any, bases: Optional[list[str]] = None, **kwargs: Any):\n    \"\"\"Initialize the object.\n\n    Arguments:\n        *args: Arguments passed to the parent class Initialize the object.\n        bases: The base classes (dotted paths).\n        **kwargs: Arguments passed to the parent class Initialize the object.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.bases = bases or [\"object\"]\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>Object</code></p> <p>A class to store information about a function.</p> <p>It accepts an additional <code>signature</code> argument at instantiation.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Function(Object):\n    \"\"\"A class to store information about a function.\n\n    It accepts an additional `signature` argument at instantiation.\n    \"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = [NAME_PRIVATE]  # noqa: RUF012\n\n    def __init__(self, *args: Any, signature: Optional[inspect.Signature] = None, **kwargs: Any):\n        \"\"\"Initialize the object.\n\n        Arguments:\n            *args: Arguments passed to the parent class Initialize the object.\n            signature: The function signature.\n            **kwargs: Arguments passed to the parent class Initialize the object.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.signature = signature\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Function.__init__","title":"<code>__init__(*args, signature=None, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>()</code> <code>signature</code> <code>Optional[Signature]</code> <p>The function signature.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>{}</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(self, *args: Any, signature: Optional[inspect.Signature] = None, **kwargs: Any):\n    \"\"\"Initialize the object.\n\n    Arguments:\n        *args: Arguments passed to the parent class Initialize the object.\n        signature: The function signature.\n        **kwargs: Arguments passed to the parent class Initialize the object.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.signature = signature\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Method","title":"<code>Method</code>","text":"<p>               Bases: <code>Object</code></p> <p>A class to store information about a method.</p> <p>It accepts an additional <code>signature</code> argument at instantiation.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Method(Object):\n    \"\"\"A class to store information about a method.\n\n    It accepts an additional `signature` argument at instantiation.\n    \"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = [NAME_SPECIAL, NAME_PRIVATE]  # noqa: RUF012\n\n    def __init__(self, *args: Any, signature: Optional[inspect.Signature] = None, **kwargs: Any):\n        \"\"\"Initialize the object.\n\n        Arguments:\n            *args: Arguments passed to the parent class Initialize the object.\n            signature: The function signature.\n            **kwargs: Arguments passed to the parent class Initialize the object.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.signature = signature\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Method.__init__","title":"<code>__init__(*args, signature=None, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>()</code> <code>signature</code> <code>Optional[Signature]</code> <p>The function signature.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arguments passed to the parent class Initialize the object.</p> <code>{}</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(self, *args: Any, signature: Optional[inspect.Signature] = None, **kwargs: Any):\n    \"\"\"Initialize the object.\n\n    Arguments:\n        *args: Arguments passed to the parent class Initialize the object.\n        signature: The function signature.\n        **kwargs: Arguments passed to the parent class Initialize the object.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.signature = signature\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Module","title":"<code>Module</code>","text":"<p>               Bases: <code>Object</code></p> <p>A class to store information about a module.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Module(Object):\n    \"\"\"A class to store information about a module.\"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = [NAME_SPECIAL, NAME_PRIVATE]  # noqa: RUF012\n\n    @property\n    def file_name(self) -&gt; str:\n        \"\"\"Return the base name of the module file, without the extension.\n\n        Returns:\n            The module file's base name.\n        \"\"\"\n        return os.path.splitext(os.path.basename(self.file_path))[0]\n\n    @property\n    def name_to_check(self) -&gt; str:  # noqa: D102\n        return self.file_name\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Module.file_name","title":"<code>file_name</code>  <code>property</code>","text":"<p>Return the base name of the module file, without the extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>The module file's base name.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object","title":"<code>Object</code>","text":"<p>A base class to store information about a Python object.</p> <p>Each instance additionally stores references to its children, grouped by category.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Object(metaclass=ABCMeta):  # noqa: B024\n    \"\"\"A base class to store information about a Python object.\n\n    Each instance additionally stores references to its children, grouped by category.\n    \"\"\"\n\n    possible_name_properties: list[ApplicableNameProperty] = []  # noqa: RUF012\n    \"\"\"\n    The properties that we can apply to the object based on its name.\n\n    The applicable properties vary from one subclass of `Object` to another.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: str,\n        file_path: str,\n        docstring: Optional[str] = \"\",\n        properties: Optional[list[str]] = None,\n        source: Optional[Source] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            name: The object's name.\n            path: The object's dotted-path.\n            file_path: The file path of the object's direct parent module.\n            docstring: The object's docstring.\n            properties: The object's properties.\n            source: The object's source code.\n        \"\"\"\n        self.name = name\n        \"\"\"The object's name.\"\"\"\n        self.path = path\n        \"\"\"The object's dotted-path.\"\"\"\n        self.file_path = file_path\n        \"\"\"The file path of the object's direct parent module.\"\"\"\n        self.docstring = docstring\n        \"\"\"The object's docstring.\"\"\"\n        self.docstring_sections: list[Section] = []\n        \"\"\"The object's docstring parsed into sections.\"\"\"\n        self.docstring_errors: list[str] = []\n        \"\"\"The errors detected while parsing the docstring.\"\"\"\n        self.properties = properties or []\n        \"\"\"The object's properties.\"\"\"\n        self.parent: Optional[Object] = None\n        \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\"\n        self.source = source\n        \"\"\"The object's source code.\"\"\"\n\n        self._path_map = {self.path: self}\n        self._parsed = False\n\n        self.attributes: list[Attribute] = []\n        \"\"\"The list of all the object's attributes.\"\"\"\n        self.methods: list[Method] = []\n        \"\"\"The list of all the object's methods.\"\"\"\n        self.functions: list[Function] = []\n        \"\"\"The list of all the object's functions.\"\"\"\n        self.modules: list[Module] = []\n        \"\"\"The list of all the object's submodules.\"\"\"\n        self.classes: list[Class] = []\n        \"\"\"The list of all the object's classes.\"\"\"\n        self.children: list[Object] = []\n        \"\"\"The list of all the object's children.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return self.path\n\n    @property\n    def category(self) -&gt; str:\n        \"\"\"Return the object's category.\n\n        Returns:\n            The object's category (module, class, function, method or attribute).\n        \"\"\"\n        return self.__class__.__name__.lower()\n\n    @property\n    def root(self) -&gt; \"Object\":\n        \"\"\"Return the object's root.\n\n        Returns:\n            The object's root (top-most parent).\n        \"\"\"\n        obj = self\n        while obj.parent:\n            obj = obj.parent\n        return obj\n\n    @property\n    def relative_file_path(self) -&gt; str:\n        \"\"\"Return the relative file path of the object.\n\n        It is the relative path to the object's module,\n        starting at the path of the top-most package it is contained in.\n\n        For example:\n\n        - package is `a`\n        - package absolute path is `/abs/path/to/a`\n        - module is `a.b.c`\n        - object is `c` or anything defined in `c`\n        - relative file path is `a/b/c.py`\n\n        If the relative file path cannot be determined, the value returned is `\"\"` (empty string).\n\n        Returns:\n            The path relative to the object's package.\n        \"\"\"\n        parts = self.path.split(\".\")\n        namespaces = [\".\".join(parts[:length]) for length in range(1, len(parts) + 1)]\n        # Iterate through all sub namespaces including the last in case it is a module\n        for namespace in namespaces:\n            try:\n                importlib.import_module(namespace)\n                top_package = sys.modules[namespace]\n            except (ModuleNotFoundError, ImportError, KeyError):\n                # ImportError: Triggered if the namespace is not importable\n                # ModuleNotFoundError: Triggered if the namespace is not a module\n                # KeyError: Triggered if the imported package isn't referenced under the same fully qualified name\n                # Namespace packages are importable, so this should work for them\n                return \"\"\n\n            try:\n                top_package_path = Path(inspect.getabsfile(top_package)).parent\n                return str(Path(self.file_path).relative_to(top_package_path.parent))\n            except TypeError:\n                # Triggered if getabsfile() can't be found in the case of a Namespace package\n                pass\n            except ValueError:\n                # Triggered if Path().relative_to can't find an appropriate path\n                return \"\"\n\n        return \"\"\n\n    @property\n    def name_to_check(self) -&gt; str:\n        \"\"\"Return the attribute to check against name-properties regular expressions (private, class-private, special).\n\n        Returns:\n            The attribute to check (its name).\n        \"\"\"\n        return self.name\n\n    @property\n    def name_properties(self) -&gt; list[str]:\n        \"\"\"Return the object's name properties.\n\n        Returns:\n            The object's name properties (private, class-private, special).\n        \"\"\"\n        properties = []\n        for prop, predicate in self.possible_name_properties:\n            if predicate(self.name_to_check):\n                properties.append(prop)\n        return properties\n\n    @property\n    def parent_path(self) -&gt; str:\n        \"\"\"Return the parent's path, computed from the current path.\n\n        The parent object path is not used: this property is used to see if an object is really related to another one,\n        to add it as a child to the other. When we do that, the child doesn't even have a parent.\n\n        Returns:\n            The dotted path of the parent object.\n        \"\"\"\n        return self.path.rsplit(\".\", 1)[0]\n\n    def add_child(self, obj: \"Object\") -&gt; None:\n        \"\"\"Add an object as a child of this object.\n\n        If the child computed `parent_path` is not equal to this object's path, abort.\n\n        Append the child to the `children` list, and to the right category list.\n\n        Arguments:\n            obj: An instance of documented object.\n        \"\"\"\n        if obj.parent_path != self.path:\n            return\n\n        self.children.append(obj)\n        if isinstance(obj, Module):\n            self.modules.append(obj)\n        elif isinstance(obj, Class):\n            self.classes.append(obj)\n        elif isinstance(obj, Function):\n            self.functions.append(obj)\n        elif isinstance(obj, Method):\n            self.methods.append(obj)\n        elif isinstance(obj, Attribute):\n            # Dataclass attributes with default values will already be present in `self.attributes` as they are\n            # resolved differently by the python interpreter. As they have a concrete value, they are already present\n            # in the \"original\" class. They should be overridden with the new \"dataclass\" attribute coming in here\n            # (having the \"dataclass_field\" property set)\n            new_attribute_name = obj.name\n            for attribute in self.attributes:\n                if attribute.name == new_attribute_name:\n                    self.attributes.remove(attribute)\n            self.attributes.append(obj)\n        obj.parent = self\n\n        self._path_map[obj.path] = obj\n\n    def add_children(self, children: list[\"Object\"]) -&gt; None:\n        \"\"\"Add a list of objects as children of this object.\n\n        Arguments:\n            children: The list of children to add.\n        \"\"\"\n        for child in children:\n            self.add_child(child)\n\n    def parse_docstring(self, parser: Parser, **context: Any) -&gt; None:\n        \"\"\"Parse the docstring of this object.\n\n        Arguments:\n            parser: A parser to parse the docstrings.\n            **context: Additional context to use when parsing.\n        \"\"\"\n        if self.docstring and not self._parsed:\n            sections, errors = parser.parse(self.docstring, {\"obj\": self, **context})\n            self.docstring_sections = sections\n            self.docstring_errors = errors\n            self._parsed = True\n\n    def parse_all_docstrings(self, parser: Parser) -&gt; None:\n        \"\"\"Recursively parse the docstring of this object and its children.\n\n        Arguments:\n            parser: A parser to parse the docstrings.\n        \"\"\"\n        self.parse_docstring(parser)\n        for child in self.children:\n            child.parse_all_docstrings(parser)\n\n    @lru_cache  # noqa: B019\n    def has_contents(self) -&gt; bool:\n        \"\"\"Tells if the object has \"contents\".\n\n        An object has contents when:\n\n        - it is the root of the object tree\n        - it has a docstring\n        - at least one of its children (whatever the depth) has contents\n\n        The value is cached, so this method should be called last, when the tree doesn't change anymore.\n\n        Returns:\n            Whether this object has contents or not.\n        \"\"\"\n        has_docstring = bool(self.docstring)\n        is_root = not self.parent\n        children_have_contents = any(child.has_contents() for child in self.children)\n        return has_docstring or is_root or children_have_contents\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.attributes","title":"<code>attributes = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's attributes.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.category","title":"<code>category</code>  <code>property</code>","text":"<p>Return the object's category.</p> <p>Returns:</p> Type Description <code>str</code> <p>The object's category (module, class, function, method or attribute).</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.children","title":"<code>children = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's children.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.classes","title":"<code>classes = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's classes.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.docstring","title":"<code>docstring = docstring</code>  <code>instance-attribute</code>","text":"<p>The object's docstring.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.docstring_errors","title":"<code>docstring_errors = []</code>  <code>instance-attribute</code>","text":"<p>The errors detected while parsing the docstring.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.docstring_sections","title":"<code>docstring_sections = []</code>  <code>instance-attribute</code>","text":"<p>The object's docstring parsed into sections.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.file_path","title":"<code>file_path = file_path</code>  <code>instance-attribute</code>","text":"<p>The file path of the object's direct parent module.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.functions","title":"<code>functions = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's functions.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.methods","title":"<code>methods = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's methods.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.modules","title":"<code>modules = []</code>  <code>instance-attribute</code>","text":"<p>The list of all the object's submodules.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":"<p>The object's name.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.name_properties","title":"<code>name_properties</code>  <code>property</code>","text":"<p>Return the object's name properties.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The object's name properties (private, class-private, special).</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.name_to_check","title":"<code>name_to_check</code>  <code>property</code>","text":"<p>Return the attribute to check against name-properties regular expressions (private, class-private, special).</p> <p>Returns:</p> Type Description <code>str</code> <p>The attribute to check (its name).</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.parent","title":"<code>parent = None</code>  <code>instance-attribute</code>","text":"<p>The object's parent (another instance of a subclass of <code>Object</code>).</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.parent_path","title":"<code>parent_path</code>  <code>property</code>","text":"<p>Return the parent's path, computed from the current path.</p> <p>The parent object path is not used: this property is used to see if an object is really related to another one, to add it as a child to the other. When we do that, the child doesn't even have a parent.</p> <p>Returns:</p> Type Description <code>str</code> <p>The dotted path of the parent object.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":"<p>The object's dotted-path.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.possible_name_properties","title":"<code>possible_name_properties = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The properties that we can apply to the object based on its name.</p> <p>The applicable properties vary from one subclass of <code>Object</code> to another.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.properties","title":"<code>properties = properties or []</code>  <code>instance-attribute</code>","text":"<p>The object's properties.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.relative_file_path","title":"<code>relative_file_path</code>  <code>property</code>","text":"<p>Return the relative file path of the object.</p> <p>It is the relative path to the object's module, starting at the path of the top-most package it is contained in.</p> <p>For example:</p> <ul> <li>package is <code>a</code></li> <li>package absolute path is <code>/abs/path/to/a</code></li> <li>module is <code>a.b.c</code></li> <li>object is <code>c</code> or anything defined in <code>c</code></li> <li>relative file path is <code>a/b/c.py</code></li> </ul> <p>If the relative file path cannot be determined, the value returned is <code>\"\"</code> (empty string).</p> <p>Returns:</p> Type Description <code>str</code> <p>The path relative to the object's package.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return the object's root.</p> <p>Returns:</p> Type Description <code>Object</code> <p>The object's root (top-most parent).</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.source","title":"<code>source = source</code>  <code>instance-attribute</code>","text":"<p>The object's source code.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.__init__","title":"<code>__init__(name, path, file_path, docstring='', properties=None, source=None)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The object's name.</p> required <code>path</code> <code>str</code> <p>The object's dotted-path.</p> required <code>file_path</code> <code>str</code> <p>The file path of the object's direct parent module.</p> required <code>docstring</code> <code>Optional[str]</code> <p>The object's docstring.</p> <code>''</code> <code>properties</code> <code>Optional[list[str]]</code> <p>The object's properties.</p> <code>None</code> <code>source</code> <code>Optional[Source]</code> <p>The object's source code.</p> <code>None</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    path: str,\n    file_path: str,\n    docstring: Optional[str] = \"\",\n    properties: Optional[list[str]] = None,\n    source: Optional[Source] = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        name: The object's name.\n        path: The object's dotted-path.\n        file_path: The file path of the object's direct parent module.\n        docstring: The object's docstring.\n        properties: The object's properties.\n        source: The object's source code.\n    \"\"\"\n    self.name = name\n    \"\"\"The object's name.\"\"\"\n    self.path = path\n    \"\"\"The object's dotted-path.\"\"\"\n    self.file_path = file_path\n    \"\"\"The file path of the object's direct parent module.\"\"\"\n    self.docstring = docstring\n    \"\"\"The object's docstring.\"\"\"\n    self.docstring_sections: list[Section] = []\n    \"\"\"The object's docstring parsed into sections.\"\"\"\n    self.docstring_errors: list[str] = []\n    \"\"\"The errors detected while parsing the docstring.\"\"\"\n    self.properties = properties or []\n    \"\"\"The object's properties.\"\"\"\n    self.parent: Optional[Object] = None\n    \"\"\"The object's parent (another instance of a subclass of `Object`).\"\"\"\n    self.source = source\n    \"\"\"The object's source code.\"\"\"\n\n    self._path_map = {self.path: self}\n    self._parsed = False\n\n    self.attributes: list[Attribute] = []\n    \"\"\"The list of all the object's attributes.\"\"\"\n    self.methods: list[Method] = []\n    \"\"\"The list of all the object's methods.\"\"\"\n    self.functions: list[Function] = []\n    \"\"\"The list of all the object's functions.\"\"\"\n    self.modules: list[Module] = []\n    \"\"\"The list of all the object's submodules.\"\"\"\n    self.classes: list[Class] = []\n    \"\"\"The list of all the object's classes.\"\"\"\n    self.children: list[Object] = []\n    \"\"\"The list of all the object's children.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.add_child","title":"<code>add_child(obj)</code>","text":"<p>Add an object as a child of this object.</p> <p>If the child computed <code>parent_path</code> is not equal to this object's path, abort.</p> <p>Append the child to the <code>children</code> list, and to the right category list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>An instance of documented object.</p> required Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def add_child(self, obj: \"Object\") -&gt; None:\n    \"\"\"Add an object as a child of this object.\n\n    If the child computed `parent_path` is not equal to this object's path, abort.\n\n    Append the child to the `children` list, and to the right category list.\n\n    Arguments:\n        obj: An instance of documented object.\n    \"\"\"\n    if obj.parent_path != self.path:\n        return\n\n    self.children.append(obj)\n    if isinstance(obj, Module):\n        self.modules.append(obj)\n    elif isinstance(obj, Class):\n        self.classes.append(obj)\n    elif isinstance(obj, Function):\n        self.functions.append(obj)\n    elif isinstance(obj, Method):\n        self.methods.append(obj)\n    elif isinstance(obj, Attribute):\n        # Dataclass attributes with default values will already be present in `self.attributes` as they are\n        # resolved differently by the python interpreter. As they have a concrete value, they are already present\n        # in the \"original\" class. They should be overridden with the new \"dataclass\" attribute coming in here\n        # (having the \"dataclass_field\" property set)\n        new_attribute_name = obj.name\n        for attribute in self.attributes:\n            if attribute.name == new_attribute_name:\n                self.attributes.remove(attribute)\n        self.attributes.append(obj)\n    obj.parent = self\n\n    self._path_map[obj.path] = obj\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.add_children","title":"<code>add_children(children)</code>","text":"<p>Add a list of objects as children of this object.</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>list[Object]</code> <p>The list of children to add.</p> required Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def add_children(self, children: list[\"Object\"]) -&gt; None:\n    \"\"\"Add a list of objects as children of this object.\n\n    Arguments:\n        children: The list of children to add.\n    \"\"\"\n    for child in children:\n        self.add_child(child)\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.has_contents","title":"<code>has_contents()</code>  <code>cached</code>","text":"<p>Tells if the object has \"contents\".</p> <p>An object has contents when:</p> <ul> <li>it is the root of the object tree</li> <li>it has a docstring</li> <li>at least one of its children (whatever the depth) has contents</li> </ul> <p>The value is cached, so this method should be called last, when the tree doesn't change anymore.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether this object has contents or not.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>@lru_cache  # noqa: B019\ndef has_contents(self) -&gt; bool:\n    \"\"\"Tells if the object has \"contents\".\n\n    An object has contents when:\n\n    - it is the root of the object tree\n    - it has a docstring\n    - at least one of its children (whatever the depth) has contents\n\n    The value is cached, so this method should be called last, when the tree doesn't change anymore.\n\n    Returns:\n        Whether this object has contents or not.\n    \"\"\"\n    has_docstring = bool(self.docstring)\n    is_root = not self.parent\n    children_have_contents = any(child.has_contents() for child in self.children)\n    return has_docstring or is_root or children_have_contents\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.parse_all_docstrings","title":"<code>parse_all_docstrings(parser)</code>","text":"<p>Recursively parse the docstring of this object and its children.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>Parser</code> <p>A parser to parse the docstrings.</p> required Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def parse_all_docstrings(self, parser: Parser) -&gt; None:\n    \"\"\"Recursively parse the docstring of this object and its children.\n\n    Arguments:\n        parser: A parser to parse the docstrings.\n    \"\"\"\n    self.parse_docstring(parser)\n    for child in self.children:\n        child.parse_all_docstrings(parser)\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Object.parse_docstring","title":"<code>parse_docstring(parser, **context)</code>","text":"<p>Parse the docstring of this object.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>Parser</code> <p>A parser to parse the docstrings.</p> required <code>**context</code> <code>Any</code> <p>Additional context to use when parsing.</p> <code>{}</code> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def parse_docstring(self, parser: Parser, **context: Any) -&gt; None:\n    \"\"\"Parse the docstring of this object.\n\n    Arguments:\n        parser: A parser to parse the docstrings.\n        **context: Additional context to use when parsing.\n    \"\"\"\n    if self.docstring and not self._parsed:\n        sections, errors = parser.parse(self.docstring, {\"obj\": self, **context})\n        self.docstring_sections = sections\n        self.docstring_errors = errors\n        self._parsed = True\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Source","title":"<code>Source</code>","text":"<p>Helper class to represent source code.</p> <p>It is simply used to wrap the result of <code>inspect.getsourceslines</code>.</p> Source code in <code>src/pytkdocs/objects.py</code> <pre><code>class Source:\n    \"\"\"Helper class to represent source code.\n\n    It is simply used to wrap the result of\n    [`inspect.getsourceslines`](https://docs.python.org/3/library/inspect.html#inspect.getsourcelines).\n    \"\"\"\n\n    def __init__(self, lines: Union[str, list[str]], line_start: int) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            lines: A list of strings. The strings should have trailing newlines.\n            line_start: The line number of where the code starts in the file.\n        \"\"\"\n        code = \"\".join(lines) if isinstance(lines, list) else lines\n        self.code = code\n        \"\"\"The code, as a single string.\"\"\"\n        self.line_start = line_start\n        \"\"\"The first line number.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Source.code","title":"<code>code = code</code>  <code>instance-attribute</code>","text":"<p>The code, as a single string.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Source.line_start","title":"<code>line_start = line_start</code>  <code>instance-attribute</code>","text":"<p>The first line number.</p>"},{"location":"reference/pytkdocs/objects/#pytkdocs.objects.Source.__init__","title":"<code>__init__(lines, line_start)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>Union[str, list[str]]</code> <p>A list of strings. The strings should have trailing newlines.</p> required <code>line_start</code> <code>int</code> <p>The line number of where the code starts in the file.</p> required Source code in <code>src/pytkdocs/objects.py</code> <pre><code>def __init__(self, lines: Union[str, list[str]], line_start: int) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        lines: A list of strings. The strings should have trailing newlines.\n        line_start: The line number of where the code starts in the file.\n    \"\"\"\n    code = \"\".join(lines) if isinstance(lines, list) else lines\n    self.code = code\n    \"\"\"The code, as a single string.\"\"\"\n    self.line_start = line_start\n    \"\"\"The first line number.\"\"\"\n</code></pre>"},{"location":"reference/pytkdocs/properties/","title":"pytkdocs.properties","text":"<p>This module simply defines regular expressions and their associated predicates.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.NAME_CLASS_PRIVATE","title":"<code>NAME_CLASS_PRIVATE = ('class-private', lambda name: bool(RE_CLASS_PRIVATE.match(name)))</code>  <code>module-attribute</code>","text":"<p>Applicable property: <code>class-private</code>.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.NAME_PRIVATE","title":"<code>NAME_PRIVATE = ('private', lambda name: bool(RE_PRIVATE.match(name)))</code>  <code>module-attribute</code>","text":"<p>Applicable property: <code>private</code>.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.NAME_SPECIAL","title":"<code>NAME_SPECIAL = ('special', lambda name: bool(RE_SPECIAL.match(name)))</code>  <code>module-attribute</code>","text":"<p>Applicable property: <code>special</code>.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.RE_CLASS_PRIVATE","title":"<code>RE_CLASS_PRIVATE = re.compile('^__[\\\\w_]*[^_]_?$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match <code>__class_private</code> names.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.RE_PRIVATE","title":"<code>RE_PRIVATE = re.compile('^_[^_][\\\\w_]*$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match <code>_private</code> names.</p>"},{"location":"reference/pytkdocs/properties/#pytkdocs.properties.RE_SPECIAL","title":"<code>RE_SPECIAL = re.compile('^__[^_]([\\\\w_]*[^_])?__$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match <code>__special__</code> names.</p>"},{"location":"reference/pytkdocs/serializer/","title":"pytkdocs.serializer","text":"<p>This module defines function to serialize objects.</p> <p>These functions simply take objects as parameters and return dictionaries that can be dumped by <code>json.dumps</code>.</p>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.RE_FORWARD_REF","title":"<code>RE_FORWARD_REF = re.compile(\"_?ForwardRef\\\\('([^']+)'\\\\)\")</code>  <code>module-attribute</code>","text":"<p>Regular expression to match forward-reference annotations of the form <code>_ForwardRef('T')</code>.</p>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.RE_OPTIONAL","title":"<code>RE_OPTIONAL = re.compile('Union\\\\[(.+), NoneType\\\\]')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match optional annotations of the form <code>Union[T, NoneType]</code>.</p>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.annotation_to_string","title":"<code>annotation_to_string(annotation)</code>","text":"<p>Return an annotation as a string.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The annotation to return as a string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The annotation as a string.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def annotation_to_string(annotation: Any) -&gt; str:\n    \"\"\"Return an annotation as a string.\n\n    Arguments:\n        annotation: The annotation to return as a string.\n\n    Returns:\n        The annotation as a string.\n    \"\"\"\n    if annotation is inspect.Signature.empty:\n        return \"\"\n\n    if inspect.isclass(annotation) and not isinstance(annotation, GenericMeta):\n        string = annotation.__name__\n    else:\n        string = str(annotation).replace(\"typing.\", \"\")\n\n    string = RE_FORWARD_REF.sub(lambda match: match.group(1), string)\n    return RE_OPTIONAL.sub(rebuild_optional, string)\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.rebuild_optional","title":"<code>rebuild_optional(match)</code>","text":"<p>Rebuild <code>Union[T, None]</code> as <code>Optional[T]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>Match</code> <p>The match object when matching against a regular expression (by the parent caller).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The rebuilt type string.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def rebuild_optional(match: Match) -&gt; str:\n    \"\"\"Rebuild `Union[T, None]` as `Optional[T]`.\n\n    Arguments:\n        match: The match object when matching against a regular expression (by the parent caller).\n\n    Returns:\n        The rebuilt type string.\n    \"\"\"\n    group = match.group(1)\n    brackets_level = 0\n    for char in group:\n        if char == \",\" and brackets_level == 0:\n            return f\"Union[{group}]\"\n        if char == \"[\":\n            brackets_level += 1\n        elif char == \"]\":\n            brackets_level -= 1\n    return f\"Optional[{group}]\"\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_annotated_object","title":"<code>serialize_annotated_object(obj)</code>","text":"<p>Serialize an instance of <code>AnnotatedObject</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>AnnotatedObject</code> <p>The object to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_annotated_object(obj: AnnotatedObject) -&gt; dict:\n    \"\"\"Serialize an instance of [`AnnotatedObject`][pytkdocs.parsers.docstrings.base.AnnotatedObject].\n\n    Arguments:\n        obj: The object to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    return {\"description\": obj.description, \"annotation\": annotation_to_string(obj.annotation)}\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_attribute","title":"<code>serialize_attribute(attribute)</code>","text":"<p>Serialize an instance of <code>Attribute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>Attribute</code> <p>The attribute to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_attribute(attribute: Attribute) -&gt; dict:\n    \"\"\"Serialize an instance of [`Attribute`][pytkdocs.parsers.docstrings.base.Attribute].\n\n    Arguments:\n        attribute: The attribute to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    return {\n        \"name\": attribute.name,\n        \"description\": attribute.description,\n        \"annotation\": annotation_to_string(attribute.annotation),\n    }\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_docstring_section","title":"<code>serialize_docstring_section(section)</code>","text":"<p>Serialize an instance of <code>inspect.Signature</code>.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>Section</code> <p>The section to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_docstring_section(section: Section) -&gt; dict:\n    \"\"\"Serialize an instance of `inspect.Signature`.\n\n    Arguments:\n        section: The section to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    serialized = {\"type\": section.type}\n    if section.type == section.Type.MARKDOWN:\n        serialized.update({\"value\": section.value})\n    elif section.type == section.Type.RETURN or section.type == section.Type.YIELD:  # noqa: PLR1714\n        serialized.update({\"value\": serialize_annotated_object(section.value)})  # type: ignore[dict-item]\n    elif section.type == section.Type.EXCEPTIONS:\n        serialized.update({\"value\": [serialize_annotated_object(exc) for exc in section.value]})  # type: ignore[dict-item]\n    elif section.type == section.Type.PARAMETERS or section.type == section.Type.KEYWORD_ARGS:  # noqa: PLR1714\n        serialized.update({\"value\": [serialize_parameter(param) for param in section.value]})  # type: ignore[dict-item]\n    elif section.type == section.Type.ATTRIBUTES:\n        serialized.update({\"value\": [serialize_attribute(attr) for attr in section.value]})  # type: ignore[dict-item]\n    elif section.type == section.Type.EXAMPLES:\n        serialized.update({\"value\": section.value})\n    return serialized\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_object","title":"<code>serialize_object(obj)</code>","text":"<p>Serialize an instance of a subclass of <code>Object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>The object to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_object(obj: Object) -&gt; dict:\n    \"\"\"Serialize an instance of a subclass of [`Object`][pytkdocs.objects.Object].\n\n    Arguments:\n        obj: The object to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    serialized = {\n        \"name\": obj.name,\n        \"path\": obj.path,\n        \"category\": obj.category,\n        \"file_path\": obj.file_path,\n        \"relative_file_path\": obj.relative_file_path,\n        \"properties\": sorted(set(obj.properties + obj.name_properties)),\n        \"parent_path\": obj.parent_path,\n        \"has_contents\": obj.has_contents(),\n        \"docstring\": obj.docstring,\n        \"docstring_sections\": [serialize_docstring_section(sec) for sec in obj.docstring_sections],\n        \"source\": serialize_source(obj.source),\n        \"children\": {child.path: serialize_object(child) for child in obj.children},\n        \"attributes\": [attr.path for attr in obj.attributes],\n        \"methods\": [meth.path for meth in obj.methods],\n        \"functions\": [func.path for func in obj.functions],\n        \"modules\": [mod.path for mod in obj.modules],\n        \"classes\": [clas.path for clas in obj.classes],\n    }\n    if hasattr(obj, \"type\"):\n        serialized[\"type\"] = annotation_to_string(obj.type)\n    if hasattr(obj, \"signature\"):\n        serialized[\"signature\"] = serialize_signature(obj.signature)\n    if hasattr(obj, \"bases\"):\n        serialized[\"bases\"] = obj.bases\n    return serialized\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_parameter","title":"<code>serialize_parameter(parameter)</code>","text":"<p>Serialize an instance of <code>Parameter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The parameter to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_parameter(parameter: Parameter) -&gt; dict:\n    \"\"\"Serialize an instance of [`Parameter`][pytkdocs.parsers.docstrings.base.Parameter].\n\n    Arguments:\n        parameter: The parameter to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    serialized = serialize_annotated_object(parameter)\n    serialized.update(\n        {\n            \"name\": parameter.name,\n            \"kind\": str(parameter.kind),\n            \"default\": parameter.default_string,\n            \"is_optional\": parameter.is_optional,\n            \"is_required\": parameter.is_required,\n            \"is_args\": parameter.is_args,\n            \"is_kwargs\": parameter.is_kwargs,\n        },\n    )\n    return serialized\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_signature","title":"<code>serialize_signature(signature)</code>","text":"<p>Serialize an instance of <code>inspect.Signature</code>.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>Signature</code> <p>The signature to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_signature(signature: inspect.Signature) -&gt; dict:\n    \"\"\"Serialize an instance of `inspect.Signature`.\n\n    Arguments:\n        signature: The signature to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    if signature is None:\n        return {}\n    serialized: dict = {\n        \"parameters\": [serialize_signature_parameter(value) for name, value in signature.parameters.items()],\n    }\n    if signature.return_annotation is not inspect.Signature.empty:\n        serialized[\"return_annotation\"] = annotation_to_string(signature.return_annotation)\n    return serialized\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_signature_parameter","title":"<code>serialize_signature_parameter(parameter)</code>","text":"<p>Serialize an instance of <code>inspect.Parameter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The parameter to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_signature_parameter(parameter: inspect.Parameter) -&gt; dict:\n    \"\"\"Serialize an instance of `inspect.Parameter`.\n\n    Arguments:\n        parameter: The parameter to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    serialized = {\"kind\": str(parameter.kind), \"name\": parameter.name}\n    if parameter.annotation is not parameter.empty:\n        serialized[\"annotation\"] = annotation_to_string(parameter.annotation)\n    if parameter.default is not parameter.empty:\n        serialized[\"default\"] = repr(parameter.default)\n    return serialized\n</code></pre>"},{"location":"reference/pytkdocs/serializer/#pytkdocs.serializer.serialize_source","title":"<code>serialize_source(source)</code>","text":"<p>Serialize an instance of <code>Source</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Optional[Source]</code> <p>The source to serialize.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A JSON-serializable dictionary.</p> Source code in <code>src/pytkdocs/serializer.py</code> <pre><code>def serialize_source(source: Optional[Source]) -&gt; dict:\n    \"\"\"Serialize an instance of [`Source`][pytkdocs.objects.Source].\n\n    Arguments:\n        source: The source to serialize.\n\n    Returns:\n        A JSON-serializable dictionary.\n    \"\"\"\n    if source:\n        return {\"code\": source.code, \"line_start\": source.line_start}\n    return {}\n</code></pre>"},{"location":"reference/pytkdocs/parsers/","title":"pytkdocs.parsers","text":"<p>The docstrings parsers' package.</p>"},{"location":"reference/pytkdocs/parsers/attributes/","title":"pytkdocs.parsers.attributes","text":"<p>Module containing functions to parse attributes in the source code.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/","title":"pytkdocs.parsers.docstrings","text":"<p>The parsers' package.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/","title":"pytkdocs.parsers.docstrings.base","text":"<p>The base module for docstring parsing.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.AnnotatedObject","title":"<code>AnnotatedObject</code>","text":"<p>A helper class to store information about an annotated object.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class AnnotatedObject:\n    \"\"\"A helper class to store information about an annotated object.\"\"\"\n\n    def __init__(self, annotation: Any, description: str) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            annotation: The object's annotation.\n            description: The object's description.\n        \"\"\"\n        self.annotation = annotation\n        self.description = description\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.AnnotatedObject.__init__","title":"<code>__init__(annotation, description)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The object's annotation.</p> required <code>description</code> <code>str</code> <p>The object's description.</p> required Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def __init__(self, annotation: Any, description: str) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        annotation: The object's annotation.\n        description: The object's description.\n    \"\"\"\n    self.annotation = annotation\n    self.description = description\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>AnnotatedObject</code></p> <p>A helper class to store information about a documented attribute.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class Attribute(AnnotatedObject):\n    \"\"\"A helper class to store information about a documented attribute.\"\"\"\n\n    def __init__(self, name: str, annotation: Any, description: str) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            name: The attribute's name.\n            annotation: The object's annotation.\n            description: The object's description.\n        \"\"\"\n        super().__init__(annotation, description)\n        self.name = name\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Attribute.__init__","title":"<code>__init__(name, annotation, description)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The attribute's name.</p> required <code>annotation</code> <code>Any</code> <p>The object's annotation.</p> required <code>description</code> <code>str</code> <p>The object's description.</p> required Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def __init__(self, name: str, annotation: Any, description: str) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        name: The attribute's name.\n        annotation: The object's annotation.\n        description: The object's description.\n    \"\"\"\n    super().__init__(annotation, description)\n    self.name = name\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>AnnotatedObject</code></p> <p>A helper class to store information about a signature parameter.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class Parameter(AnnotatedObject):\n    \"\"\"A helper class to store information about a signature parameter.\"\"\"\n\n    def __init__(self, name: str, annotation: Any, description: str, kind: Any, default: Any = empty) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            name: The parameter's name.\n            annotation: The parameter's annotation.\n            description: The parameter's description.\n            kind: The parameter's kind (positional only, keyword only, etc.).\n            default: The parameter's default value.\n        \"\"\"\n        super().__init__(annotation, description)\n        self.name = name\n        self.kind = kind\n        self.default = default\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"&lt;Parameter({self.name}, {self.annotation}, {self.description}, {self.kind}, {self.default})&gt;\"\n\n    @property\n    def is_optional(self) -&gt; bool:\n        \"\"\"Tell if this parameter is optional.\"\"\"\n        return self.default is not empty\n\n    @property\n    def is_required(self) -&gt; bool:\n        \"\"\"Tell if this parameter is required.\"\"\"\n        return not self.is_optional\n\n    @property\n    def is_args(self) -&gt; bool:\n        \"\"\"Tell if this parameter is positional.\"\"\"\n        return self.kind is inspect.Parameter.VAR_POSITIONAL\n\n    @property\n    def is_kwargs(self) -&gt; bool:\n        \"\"\"Tell if this parameter is a keyword.\"\"\"\n        return self.kind is inspect.Parameter.VAR_KEYWORD\n\n    @property\n    def default_string(self) -&gt; str:\n        \"\"\"Return the default value as a string.\"\"\"\n        if self.is_kwargs:\n            return \"{}\"\n        if self.is_args:\n            return \"()\"\n        if self.is_required:\n            return \"\"\n        return repr(self.default)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.default_string","title":"<code>default_string</code>  <code>property</code>","text":"<p>Return the default value as a string.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_args","title":"<code>is_args</code>  <code>property</code>","text":"<p>Tell if this parameter is positional.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_kwargs","title":"<code>is_kwargs</code>  <code>property</code>","text":"<p>Tell if this parameter is a keyword.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_optional","title":"<code>is_optional</code>  <code>property</code>","text":"<p>Tell if this parameter is optional.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.is_required","title":"<code>is_required</code>  <code>property</code>","text":"<p>Tell if this parameter is required.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parameter.__init__","title":"<code>__init__(name, annotation, description, kind, default=empty)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The parameter's name.</p> required <code>annotation</code> <code>Any</code> <p>The parameter's annotation.</p> required <code>description</code> <code>str</code> <p>The parameter's description.</p> required <code>kind</code> <code>Any</code> <p>The parameter's kind (positional only, keyword only, etc.).</p> required <code>default</code> <code>Any</code> <p>The parameter's default value.</p> <code>empty</code> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def __init__(self, name: str, annotation: Any, description: str, kind: Any, default: Any = empty) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        name: The parameter's name.\n        annotation: The parameter's annotation.\n        description: The parameter's description.\n        kind: The parameter's kind (positional only, keyword only, etc.).\n        default: The parameter's default value.\n    \"\"\"\n    super().__init__(annotation, description)\n    self.name = name\n    self.kind = kind\n    self.default = default\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser","title":"<code>Parser</code>","text":"<p>A class to parse docstrings.</p> <p>It is instantiated with an object's path, docstring, signature and return type.</p> <p>The <code>parse</code> method then returns structured data, in the form of a list of <code>Section</code>s. It also return the list of errors that occurred during parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class Parser(metaclass=ABCMeta):\n    \"\"\"A class to parse docstrings.\n\n    It is instantiated with an object's path, docstring, signature and return type.\n\n    The `parse` method then returns structured data,\n    in the form of a list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s.\n    It also return the list of errors that occurred during parsing.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:  # noqa: ARG002\n        \"\"\"Initialize the object.\"\"\"\n        self.context: dict = {}\n        self.errors: list[str] = []\n\n    def parse(self, docstring: str, context: Optional[dict] = None) -&gt; tuple[list[Section], list[str]]:\n        \"\"\"Parse a docstring and return a list of sections and parsing errors.\n\n        Arguments:\n            docstring: The docstring to parse.\n            context: Some context helping to parse the docstring.\n\n        Returns:\n            A tuple containing the list of sections and the parsing errors.\n        \"\"\"\n        self.context = context or {}\n        self.errors = []\n        sections = self.parse_sections(docstring)\n        errors = self.errors\n        return sections, errors\n\n    def error(self, message: str) -&gt; None:\n        \"\"\"Record a parsing error.\n\n        Arguments:\n            message: A message described the error.\n        \"\"\"\n        if self.context[\"obj\"]:\n            message = f\"{self.context['obj'].path}: {message}\"\n        self.errors.append(message)\n\n    @abstractmethod\n    def parse_sections(self, docstring: str) -&gt; list[Section]:\n        \"\"\"Parse a docstring as a list of sections.\n\n        Arguments:\n            docstring: The docstring to parse.\n\n        Returns:\n            A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the object.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"Initialize the object.\"\"\"\n    self.context: dict = {}\n    self.errors: list[str] = []\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.error","title":"<code>error(message)</code>","text":"<p>Record a parsing error.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A message described the error.</p> required Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def error(self, message: str) -&gt; None:\n    \"\"\"Record a parsing error.\n\n    Arguments:\n        message: A message described the error.\n    \"\"\"\n    if self.context[\"obj\"]:\n        message = f\"{self.context['obj'].path}: {message}\"\n    self.errors.append(message)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.parse","title":"<code>parse(docstring, context=None)</code>","text":"<p>Parse a docstring and return a list of sections and parsing errors.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The docstring to parse.</p> required <code>context</code> <code>Optional[dict]</code> <p>Some context helping to parse the docstring.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[Section], list[str]]</code> <p>A tuple containing the list of sections and the parsing errors.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def parse(self, docstring: str, context: Optional[dict] = None) -&gt; tuple[list[Section], list[str]]:\n    \"\"\"Parse a docstring and return a list of sections and parsing errors.\n\n    Arguments:\n        docstring: The docstring to parse.\n        context: Some context helping to parse the docstring.\n\n    Returns:\n        A tuple containing the list of sections and the parsing errors.\n    \"\"\"\n    self.context = context or {}\n    self.errors = []\n    sections = self.parse_sections(docstring)\n    errors = self.errors\n    return sections, errors\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Parser.parse_sections","title":"<code>parse_sections(docstring)</code>  <code>abstractmethod</code>","text":"<p>Parse a docstring as a list of sections.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The docstring to parse.</p> required <p>Returns:</p> Type Description <code>list[Section]</code> <p>A list of <code>Section</code>s.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>@abstractmethod\ndef parse_sections(self, docstring: str) -&gt; list[Section]:\n    \"\"\"Parse a docstring as a list of sections.\n\n    Arguments:\n        docstring: The docstring to parse.\n\n    Returns:\n        A list of [`Section`][pytkdocs.parsers.docstrings.base.Section]s.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section","title":"<code>Section</code>","text":"<p>A helper class to store a docstring section.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class Section:\n    \"\"\"A helper class to store a docstring section.\"\"\"\n\n    class Type:\n        \"\"\"The possible section types.\"\"\"\n\n        MARKDOWN = \"markdown\"\n        PARAMETERS = \"parameters\"\n        EXCEPTIONS = \"exceptions\"\n        RETURN = \"return\"\n        YIELD = \"yield\"\n        EXAMPLES = \"examples\"\n        ATTRIBUTES = \"attributes\"\n        KEYWORD_ARGS = \"keyword_args\"\n\n    def __init__(self, section_type: str, value: Any) -&gt; None:\n        \"\"\"Initialize the object.\n\n        Arguments:\n            section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum.\n            value: The section value.\n        \"\"\"\n        self.type = section_type\n        self.value = value\n\n    def __str__(self):\n        return self.type\n\n    def __repr__(self):\n        return f\"&lt;Section(type={self.type!r})&gt;\"\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section.Type","title":"<code>Type</code>","text":"<p>The possible section types.</p> Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>class Type:\n    \"\"\"The possible section types.\"\"\"\n\n    MARKDOWN = \"markdown\"\n    PARAMETERS = \"parameters\"\n    EXCEPTIONS = \"exceptions\"\n    RETURN = \"return\"\n    YIELD = \"yield\"\n    EXAMPLES = \"examples\"\n    ATTRIBUTES = \"attributes\"\n    KEYWORD_ARGS = \"keyword_args\"\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/base/#pytkdocs.parsers.docstrings.base.Section.__init__","title":"<code>__init__(section_type, value)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>section_type</code> <code>str</code> <p>The type of the section, from the <code>Type</code> enum.</p> required <code>value</code> <code>Any</code> <p>The section value.</p> required Source code in <code>src/pytkdocs/parsers/docstrings/base.py</code> <pre><code>def __init__(self, section_type: str, value: Any) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Arguments:\n        section_type: The type of the section, from the [`Type`][pytkdocs.parsers.docstrings.base.Section.Type] enum.\n        value: The section value.\n    \"\"\"\n    self.type = section_type\n    self.value = value\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/","title":"pytkdocs.parsers.docstrings.google","text":"<p>This module defines functions and classes to parse docstrings into structured data.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.RE_DOCTEST_BLANKLINE","title":"<code>RE_DOCTEST_BLANKLINE = re.compile('^\\\\s*&lt;BLANKLINE&gt;\\\\s*$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match lines of the form <code>&lt;BLANKLINE&gt;</code>.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.RE_DOCTEST_FLAGS","title":"<code>RE_DOCTEST_FLAGS = re.compile('(\\\\s*#\\\\s*doctest:.+)$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match lines containing doctest flags of the form <code># doctest: +FLAG</code>.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.RE_GOOGLE_STYLE_ADMONITION","title":"<code>RE_GOOGLE_STYLE_ADMONITION = re.compile('^(?P&lt;indent&gt;\\\\s*)(?P&lt;type&gt;[\\\\w-]+):((?:\\\\s+)(?P&lt;title&gt;.+))?$')</code>  <code>module-attribute</code>","text":"<p>Regular expressions to match lines starting admonitions, of the form <code>TYPE: [TITLE]</code>.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google","title":"<code>Google</code>","text":"<p>               Bases: <code>Parser</code></p> <p>A Google-style docstrings parser.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>class Google(Parser):\n    \"\"\"A Google-style docstrings parser.\"\"\"\n\n    def __init__(self, replace_admonitions: bool = True, trim_doctest_flags: bool = True, **kwargs: Any) -&gt; None:  # noqa: FBT001, FBT002, ARG002\n        \"\"\"Initialize the object.\n\n        Arguments:\n            replace_admonitions: Whether to replace admonitions by their Markdown equivalent.\n            trim_doctest_flags: Whether to remove doctest flags.\n        \"\"\"\n        super().__init__()\n        self.replace_admonitions = replace_admonitions\n        self.trim_doctest_flags = trim_doctest_flags\n        self.section_reader = {\n            Section.Type.PARAMETERS: self.read_parameters_section,\n            Section.Type.KEYWORD_ARGS: self.read_keyword_arguments_section,\n            Section.Type.EXCEPTIONS: self.read_exceptions_section,\n            Section.Type.EXAMPLES: self.read_examples_section,\n            Section.Type.ATTRIBUTES: self.read_attributes_section,\n            Section.Type.RETURN: self.read_return_section,\n            Section.Type.YIELD: self.read_yield_section,\n        }\n\n    def parse_sections(self, docstring: str) -&gt; list[Section]:  # noqa: D102\n        if \"signature\" not in self.context:\n            self.context[\"signature\"] = getattr(self.context[\"obj\"], \"signature\", None)\n        if \"annotation\" not in self.context:\n            self.context[\"annotation\"] = getattr(self.context[\"obj\"], \"type\", empty)\n        if \"attributes\" not in self.context:\n            self.context[\"attributes\"] = {}\n\n        sections = []\n        current_section = []\n\n        in_code_block = False\n\n        lines = docstring.split(\"\\n\")\n        i = 0\n\n        while i &lt; len(lines):\n            line_lower = lines[i].lower()\n\n            if in_code_block:\n                if line_lower.lstrip(\" \").startswith(\"```\"):\n                    in_code_block = False\n                current_section.append(lines[i])\n\n            elif line_lower in SECTIONS_TITLES:\n                if current_section:\n                    if any(current_section):\n                        sections.append(Section(Section.Type.MARKDOWN, \"\\n\".join(current_section)))\n                    current_section = []\n                section_reader = self.section_reader[SECTIONS_TITLES[line_lower]]\n                section, i = section_reader(lines, i + 1)\n                if section:\n                    sections.append(section)\n\n            elif line_lower.lstrip(\" \").startswith(\"```\"):\n                in_code_block = True\n                current_section.append(lines[i])\n\n            else:\n                if self.replace_admonitions and not in_code_block and i + 1 &lt; len(lines):\n                    match = RE_GOOGLE_STYLE_ADMONITION.match(lines[i])\n                    if match:\n                        groups = match.groupdict()\n                        indent = groups[\"indent\"]\n                        if lines[i + 1].startswith(indent + \" \" * 4):\n                            lines[i] = f\"{indent}!!! {groups['type'].lower()}\"\n                            if groups[\"title\"]:\n                                lines[i] += f' \"{groups[\"title\"]}\"'\n                current_section.append(lines[i])\n\n            i += 1\n\n        if current_section:\n            sections.append(Section(Section.Type.MARKDOWN, \"\\n\".join(current_section)))\n\n        return sections\n\n    def read_block_items(self, lines: list[str], start_index: int) -&gt; tuple[list[str], int]:\n        \"\"\"Parse an indented block as a list of items.\n\n        The first indentation level is used as a reference to determine if the next lines are new items\n        or continuation lines.\n\n        Arguments:\n            lines: The block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing the list of concatenated lines and the index at which to continue parsing.\n        \"\"\"\n        if start_index &gt;= len(lines):\n            return [], start_index\n\n        i = start_index\n        items: list[str] = []\n\n        # skip first empty lines\n        while is_empty_line(lines[i]):\n            i += 1\n\n        # get initial indent\n        indent = len(lines[i]) - len(lines[i].lstrip())\n\n        if indent == 0:\n            # first non-empty line was not indented, abort\n            return [], i - 1\n\n        # start processing first item\n        current_item = [lines[i][indent:]]\n        i += 1\n\n        # loop on next lines\n        while i &lt; len(lines):\n            line = lines[i]\n\n            if line.startswith(indent * 2 * \" \"):\n                # continuation line\n                current_item.append(line[indent * 2 :])\n\n            elif line.startswith((indent + 1) * \" \"):\n                # indent between initial and continuation: append but add error\n                cont_indent = len(line) - len(line.lstrip())\n                current_item.append(line[cont_indent:])\n                self.error(\n                    f\"Confusing indentation for continuation line {i + 1} in docstring, \"\n                    f\"should be {indent} * 2 = {indent * 2} spaces, not {cont_indent}\",\n                )\n\n            elif line.startswith(indent * \" \"):\n                # indent equal to initial one: new item\n                items.append(\"\\n\".join(current_item))\n                current_item = [line[indent:]]\n\n            elif is_empty_line(line):\n                # empty line: preserve it in the current item\n                current_item.append(\"\")\n\n            else:\n                # indent lower than initial one: end of section\n                break\n\n            i += 1\n\n        if current_item:\n            items.append(\"\\n\".join(current_item).rstrip(\"\\n\"))\n\n        return items, i - 1\n\n    def read_block(self, lines: list[str], start_index: int) -&gt; tuple[str, int]:\n        \"\"\"Parse an indented block.\n\n        Arguments:\n            lines: The block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing the list of lines and the index at which to continue parsing.\n        \"\"\"\n        if start_index &gt;= len(lines):\n            return \"\", start_index\n\n        i = start_index\n        block: list[str] = []\n\n        # skip first empty lines\n        while is_empty_line(lines[i]):\n            i += 1\n\n        # get initial indent\n        indent = len(lines[i]) - len(lines[i].lstrip())\n\n        if indent == 0:\n            # first non-empty line was not indented, abort\n            return \"\", i - 1\n\n        # start processing first item\n        block.append(lines[i].lstrip())\n        i += 1\n\n        # loop on next lines\n        while i &lt; len(lines) and (lines[i].startswith(indent * \" \") or is_empty_line(lines[i])):\n            block.append(lines[i][indent:])\n            i += 1\n\n        return \"\\n\".join(block).rstrip(\"\\n\"), i - 1\n\n    def _parse_parameters_section(self, lines: list[str], start_index: int) -&gt; tuple[list[Parameter], int]:\n        \"\"\"Parse a \"parameters\" or \"keyword args\" section.\n\n        Arguments:\n            lines: The parameters block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        parameters = []\n        type_: Any\n        block, i = self.read_block_items(lines, start_index)\n\n        for param_line in block:\n            # Check that there is an annotation in the docstring\n            try:\n                name_with_type, description = param_line.split(\":\", 1)\n            except ValueError:\n                self.error(f\"Failed to get 'name: description' pair from '{param_line}'\")\n                continue\n\n            # Setting defaults\n            default = empty\n            annotation = empty\n            kind = None\n            # Can only get description from docstring - keep if no type was given\n            description = description.lstrip()\n\n            # If we have managed to find a type in the docstring use this\n            if \" \" in name_with_type:\n                name, type_ = name_with_type.split(\" \", 1)\n                annotation = type_.strip(\"()\")\n                if annotation.endswith(\", optional\"):  # type: ignore[attr-defined]\n                    annotation = annotation[:-10]  # type: ignore[misc]\n            # Otherwise try to use the signature as `annotation` would still be empty\n            else:\n                name = name_with_type\n\n            # Check in the signature to get extra details\n            try:\n                signature_param = self.context[\"signature\"].parameters[name.lstrip(\"*\")]\n            except (AttributeError, KeyError):\n                if annotation is empty:\n                    self.error(f\"No type annotation for parameter '{name}'\")\n            else:\n                if annotation is empty:\n                    annotation = signature_param.annotation\n                # If signature_param.X are empty it doesnt matter as defaults are empty anyway\n                default = signature_param.default\n                kind = signature_param.kind\n\n            parameters.append(\n                Parameter(name=name, annotation=annotation, description=description, default=default, kind=kind),\n            )\n\n        return parameters, i\n\n    def read_parameters_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse a \"parameters\" section.\n\n        Arguments:\n            lines: The parameters block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        parameters, i = self._parse_parameters_section(lines, start_index)\n\n        if parameters:\n            return Section(Section.Type.PARAMETERS, parameters), i\n\n        self.error(f\"Empty parameters section at line {start_index}\")\n        return None, i\n\n    def read_keyword_arguments_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse a \"keyword arguments\" section.\n\n        Arguments:\n            lines: The parameters block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        parameters, i = self._parse_parameters_section(lines, start_index)\n        for parameter in parameters:\n            parameter.kind = inspect.Parameter.KEYWORD_ONLY\n\n        if parameters:\n            return Section(Section.Type.KEYWORD_ARGS, parameters), i\n\n        self.error(f\"Empty keyword arguments section at line {start_index}\")\n        return None, i\n\n    def read_attributes_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse an \"attributes\" section.\n\n        Arguments:\n            lines: The parameters block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        attributes = []\n        block, i = self.read_block_items(lines, start_index)\n\n        for attr_line in block:\n            try:\n                name_with_type, description = attr_line.split(\":\", 1)\n            except ValueError:\n                self.error(f\"Failed to get 'name: description' pair from '{attr_line}'\")\n                continue\n\n            description = description.lstrip()\n\n            if \" \" in name_with_type:\n                name, annotation = name_with_type.split(\" \", 1)\n                annotation = annotation.strip(\"()\")\n                if annotation.endswith(\", optional\"):\n                    annotation = annotation[:-10]\n            else:\n                name = name_with_type\n                annotation = self.context[\"attributes\"].get(name, {}).get(\"annotation\", empty)\n\n            attributes.append(Attribute(name=name, annotation=annotation, description=description))\n\n        if attributes:\n            return Section(Section.Type.ATTRIBUTES, attributes), i\n\n        self.error(f\"Empty attributes section at line {start_index}\")\n        return None, i\n\n    def read_exceptions_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse an \"exceptions\" section.\n\n        Arguments:\n            lines: The exceptions block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        exceptions = []\n        block, i = self.read_block_items(lines, start_index)\n\n        for exception_line in block:\n            try:\n                annotation, description = exception_line.split(\": \", 1)\n            except ValueError:\n                self.error(f\"Failed to get 'exception: description' pair from '{exception_line}'\")\n            else:\n                exceptions.append(AnnotatedObject(annotation, description.lstrip(\" \")))\n\n        if exceptions:\n            return Section(Section.Type.EXCEPTIONS, exceptions), i\n\n        self.error(f\"Empty exceptions section at line {start_index}\")\n        return None, i\n\n    def read_return_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse an \"returns\" section.\n\n        Arguments:\n            lines: The return block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        text, i = self.read_block(lines, start_index)\n\n        # Early exit if there is no text in the return section\n        if not text:\n            self.error(f\"Empty return section at line {start_index}\")\n            return None, i\n\n        # First try to get the annotation and description from the docstring\n        try:\n            type_, text = text.split(\":\", 1)\n        except ValueError:\n            description = text\n            annotation = self.context[\"annotation\"]\n            # If there was no annotation in the docstring then move to signature\n            if annotation is empty and self.context[\"signature\"]:\n                annotation = self.context[\"signature\"].return_annotation\n        else:\n            annotation = type_.lstrip()\n            description = text.lstrip()\n\n        # There was no type in the docstring and no annotation\n        if annotation is empty:\n            self.error(\"No return type/annotation in docstring/signature\")\n\n        return Section(Section.Type.RETURN, AnnotatedObject(annotation, description)), i\n\n    def read_yield_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse a \"yields\" section.\n\n        Arguments:\n            lines: The return block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        text, i = self.read_block(lines, start_index)\n\n        # Early exit if there is no text in the yield section\n        if not text:\n            self.error(f\"Empty yield section at line {start_index}\")\n            return None, i\n\n        # First try to get the annotation and description from the docstring\n        try:\n            type_, text = text.split(\":\", 1)\n        except ValueError:\n            description = text\n            annotation = self.context[\"annotation\"]\n            # If there was no annotation in the docstring then move to signature\n            if annotation is empty and self.context[\"signature\"]:\n                annotation = self.context[\"signature\"].return_annotation\n        else:\n            annotation = type_.lstrip()\n            description = text.lstrip()\n\n        # There was no type in the docstring and no annotation\n        if annotation is empty:\n            self.error(\"No yield type/annotation in docstring/signature\")\n\n        return Section(Section.Type.YIELD, AnnotatedObject(annotation, description)), i\n\n    def read_examples_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n        \"\"\"Parse an \"examples\" section.\n\n        Arguments:\n            lines: The examples block lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        text, i = self.read_block(lines, start_index)\n\n        sub_sections = []\n        in_code_example = False\n        in_code_block = False\n        current_text: list[str] = []\n        current_example: list[str] = []\n\n        for line in text.split(\"\\n\"):\n            if is_empty_line(line):\n                if in_code_example:\n                    if current_example:\n                        sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n                        current_example = []\n                    in_code_example = False\n                else:\n                    current_text.append(line)\n\n            elif in_code_example:\n                if self.trim_doctest_flags:\n                    line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                    line = RE_DOCTEST_BLANKLINE.sub(\"\", line)  # noqa: PLW2901\n                current_example.append(line)\n\n            elif line.startswith(\"```\"):\n                in_code_block = not in_code_block\n                current_text.append(line)\n\n            elif in_code_block:\n                current_text.append(line)\n\n            elif line.startswith(\"&gt;&gt;&gt;\"):\n                if current_text:\n                    sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n                    current_text = []\n                in_code_example = True\n\n                if self.trim_doctest_flags:\n                    line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                current_example.append(line)\n\n            else:\n                current_text.append(line)\n\n        if current_text:\n            sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n        elif current_example:\n            sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n\n        if sub_sections:\n            return Section(Section.Type.EXAMPLES, sub_sections), i\n\n        self.error(f\"Empty examples section at line {start_index}\")\n        return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.__init__","title":"<code>__init__(replace_admonitions=True, trim_doctest_flags=True, **kwargs)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>replace_admonitions</code> <code>bool</code> <p>Whether to replace admonitions by their Markdown equivalent.</p> <code>True</code> <code>trim_doctest_flags</code> <code>bool</code> <p>Whether to remove doctest flags.</p> <code>True</code> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def __init__(self, replace_admonitions: bool = True, trim_doctest_flags: bool = True, **kwargs: Any) -&gt; None:  # noqa: FBT001, FBT002, ARG002\n    \"\"\"Initialize the object.\n\n    Arguments:\n        replace_admonitions: Whether to replace admonitions by their Markdown equivalent.\n        trim_doctest_flags: Whether to remove doctest flags.\n    \"\"\"\n    super().__init__()\n    self.replace_admonitions = replace_admonitions\n    self.trim_doctest_flags = trim_doctest_flags\n    self.section_reader = {\n        Section.Type.PARAMETERS: self.read_parameters_section,\n        Section.Type.KEYWORD_ARGS: self.read_keyword_arguments_section,\n        Section.Type.EXCEPTIONS: self.read_exceptions_section,\n        Section.Type.EXAMPLES: self.read_examples_section,\n        Section.Type.ATTRIBUTES: self.read_attributes_section,\n        Section.Type.RETURN: self.read_return_section,\n        Section.Type.YIELD: self.read_yield_section,\n    }\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google._parse_parameters_section","title":"<code>_parse_parameters_section(lines, start_index)</code>","text":"<p>Parse a \"parameters\" or \"keyword args\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The parameters block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[list[Parameter], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def _parse_parameters_section(self, lines: list[str], start_index: int) -&gt; tuple[list[Parameter], int]:\n    \"\"\"Parse a \"parameters\" or \"keyword args\" section.\n\n    Arguments:\n        lines: The parameters block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    parameters = []\n    type_: Any\n    block, i = self.read_block_items(lines, start_index)\n\n    for param_line in block:\n        # Check that there is an annotation in the docstring\n        try:\n            name_with_type, description = param_line.split(\":\", 1)\n        except ValueError:\n            self.error(f\"Failed to get 'name: description' pair from '{param_line}'\")\n            continue\n\n        # Setting defaults\n        default = empty\n        annotation = empty\n        kind = None\n        # Can only get description from docstring - keep if no type was given\n        description = description.lstrip()\n\n        # If we have managed to find a type in the docstring use this\n        if \" \" in name_with_type:\n            name, type_ = name_with_type.split(\" \", 1)\n            annotation = type_.strip(\"()\")\n            if annotation.endswith(\", optional\"):  # type: ignore[attr-defined]\n                annotation = annotation[:-10]  # type: ignore[misc]\n        # Otherwise try to use the signature as `annotation` would still be empty\n        else:\n            name = name_with_type\n\n        # Check in the signature to get extra details\n        try:\n            signature_param = self.context[\"signature\"].parameters[name.lstrip(\"*\")]\n        except (AttributeError, KeyError):\n            if annotation is empty:\n                self.error(f\"No type annotation for parameter '{name}'\")\n        else:\n            if annotation is empty:\n                annotation = signature_param.annotation\n            # If signature_param.X are empty it doesnt matter as defaults are empty anyway\n            default = signature_param.default\n            kind = signature_param.kind\n\n        parameters.append(\n            Parameter(name=name, annotation=annotation, description=description, default=default, kind=kind),\n        )\n\n    return parameters, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_attributes_section","title":"<code>read_attributes_section(lines, start_index)</code>","text":"<p>Parse an \"attributes\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The parameters block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_attributes_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse an \"attributes\" section.\n\n    Arguments:\n        lines: The parameters block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    attributes = []\n    block, i = self.read_block_items(lines, start_index)\n\n    for attr_line in block:\n        try:\n            name_with_type, description = attr_line.split(\":\", 1)\n        except ValueError:\n            self.error(f\"Failed to get 'name: description' pair from '{attr_line}'\")\n            continue\n\n        description = description.lstrip()\n\n        if \" \" in name_with_type:\n            name, annotation = name_with_type.split(\" \", 1)\n            annotation = annotation.strip(\"()\")\n            if annotation.endswith(\", optional\"):\n                annotation = annotation[:-10]\n        else:\n            name = name_with_type\n            annotation = self.context[\"attributes\"].get(name, {}).get(\"annotation\", empty)\n\n        attributes.append(Attribute(name=name, annotation=annotation, description=description))\n\n    if attributes:\n        return Section(Section.Type.ATTRIBUTES, attributes), i\n\n    self.error(f\"Empty attributes section at line {start_index}\")\n    return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_block","title":"<code>read_block(lines, start_index)</code>","text":"<p>Parse an indented block.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[str, int]</code> <p>A tuple containing the list of lines and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_block(self, lines: list[str], start_index: int) -&gt; tuple[str, int]:\n    \"\"\"Parse an indented block.\n\n    Arguments:\n        lines: The block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing the list of lines and the index at which to continue parsing.\n    \"\"\"\n    if start_index &gt;= len(lines):\n        return \"\", start_index\n\n    i = start_index\n    block: list[str] = []\n\n    # skip first empty lines\n    while is_empty_line(lines[i]):\n        i += 1\n\n    # get initial indent\n    indent = len(lines[i]) - len(lines[i].lstrip())\n\n    if indent == 0:\n        # first non-empty line was not indented, abort\n        return \"\", i - 1\n\n    # start processing first item\n    block.append(lines[i].lstrip())\n    i += 1\n\n    # loop on next lines\n    while i &lt; len(lines) and (lines[i].startswith(indent * \" \") or is_empty_line(lines[i])):\n        block.append(lines[i][indent:])\n        i += 1\n\n    return \"\\n\".join(block).rstrip(\"\\n\"), i - 1\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_block_items","title":"<code>read_block_items(lines, start_index)</code>","text":"<p>Parse an indented block as a list of items.</p> <p>The first indentation level is used as a reference to determine if the next lines are new items or continuation lines.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], int]</code> <p>A tuple containing the list of concatenated lines and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_block_items(self, lines: list[str], start_index: int) -&gt; tuple[list[str], int]:\n    \"\"\"Parse an indented block as a list of items.\n\n    The first indentation level is used as a reference to determine if the next lines are new items\n    or continuation lines.\n\n    Arguments:\n        lines: The block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing the list of concatenated lines and the index at which to continue parsing.\n    \"\"\"\n    if start_index &gt;= len(lines):\n        return [], start_index\n\n    i = start_index\n    items: list[str] = []\n\n    # skip first empty lines\n    while is_empty_line(lines[i]):\n        i += 1\n\n    # get initial indent\n    indent = len(lines[i]) - len(lines[i].lstrip())\n\n    if indent == 0:\n        # first non-empty line was not indented, abort\n        return [], i - 1\n\n    # start processing first item\n    current_item = [lines[i][indent:]]\n    i += 1\n\n    # loop on next lines\n    while i &lt; len(lines):\n        line = lines[i]\n\n        if line.startswith(indent * 2 * \" \"):\n            # continuation line\n            current_item.append(line[indent * 2 :])\n\n        elif line.startswith((indent + 1) * \" \"):\n            # indent between initial and continuation: append but add error\n            cont_indent = len(line) - len(line.lstrip())\n            current_item.append(line[cont_indent:])\n            self.error(\n                f\"Confusing indentation for continuation line {i + 1} in docstring, \"\n                f\"should be {indent} * 2 = {indent * 2} spaces, not {cont_indent}\",\n            )\n\n        elif line.startswith(indent * \" \"):\n            # indent equal to initial one: new item\n            items.append(\"\\n\".join(current_item))\n            current_item = [line[indent:]]\n\n        elif is_empty_line(line):\n            # empty line: preserve it in the current item\n            current_item.append(\"\")\n\n        else:\n            # indent lower than initial one: end of section\n            break\n\n        i += 1\n\n    if current_item:\n        items.append(\"\\n\".join(current_item).rstrip(\"\\n\"))\n\n    return items, i - 1\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_examples_section","title":"<code>read_examples_section(lines, start_index)</code>","text":"<p>Parse an \"examples\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The examples block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_examples_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse an \"examples\" section.\n\n    Arguments:\n        lines: The examples block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    text, i = self.read_block(lines, start_index)\n\n    sub_sections = []\n    in_code_example = False\n    in_code_block = False\n    current_text: list[str] = []\n    current_example: list[str] = []\n\n    for line in text.split(\"\\n\"):\n        if is_empty_line(line):\n            if in_code_example:\n                if current_example:\n                    sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n                    current_example = []\n                in_code_example = False\n            else:\n                current_text.append(line)\n\n        elif in_code_example:\n            if self.trim_doctest_flags:\n                line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                line = RE_DOCTEST_BLANKLINE.sub(\"\", line)  # noqa: PLW2901\n            current_example.append(line)\n\n        elif line.startswith(\"```\"):\n            in_code_block = not in_code_block\n            current_text.append(line)\n\n        elif in_code_block:\n            current_text.append(line)\n\n        elif line.startswith(\"&gt;&gt;&gt;\"):\n            if current_text:\n                sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n                current_text = []\n            in_code_example = True\n\n            if self.trim_doctest_flags:\n                line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n            current_example.append(line)\n\n        else:\n            current_text.append(line)\n\n    if current_text:\n        sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n    elif current_example:\n        sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n\n    if sub_sections:\n        return Section(Section.Type.EXAMPLES, sub_sections), i\n\n    self.error(f\"Empty examples section at line {start_index}\")\n    return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_exceptions_section","title":"<code>read_exceptions_section(lines, start_index)</code>","text":"<p>Parse an \"exceptions\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The exceptions block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_exceptions_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse an \"exceptions\" section.\n\n    Arguments:\n        lines: The exceptions block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    exceptions = []\n    block, i = self.read_block_items(lines, start_index)\n\n    for exception_line in block:\n        try:\n            annotation, description = exception_line.split(\": \", 1)\n        except ValueError:\n            self.error(f\"Failed to get 'exception: description' pair from '{exception_line}'\")\n        else:\n            exceptions.append(AnnotatedObject(annotation, description.lstrip(\" \")))\n\n    if exceptions:\n        return Section(Section.Type.EXCEPTIONS, exceptions), i\n\n    self.error(f\"Empty exceptions section at line {start_index}\")\n    return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_keyword_arguments_section","title":"<code>read_keyword_arguments_section(lines, start_index)</code>","text":"<p>Parse a \"keyword arguments\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The parameters block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_keyword_arguments_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse a \"keyword arguments\" section.\n\n    Arguments:\n        lines: The parameters block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    parameters, i = self._parse_parameters_section(lines, start_index)\n    for parameter in parameters:\n        parameter.kind = inspect.Parameter.KEYWORD_ONLY\n\n    if parameters:\n        return Section(Section.Type.KEYWORD_ARGS, parameters), i\n\n    self.error(f\"Empty keyword arguments section at line {start_index}\")\n    return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_parameters_section","title":"<code>read_parameters_section(lines, start_index)</code>","text":"<p>Parse a \"parameters\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The parameters block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_parameters_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse a \"parameters\" section.\n\n    Arguments:\n        lines: The parameters block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    parameters, i = self._parse_parameters_section(lines, start_index)\n\n    if parameters:\n        return Section(Section.Type.PARAMETERS, parameters), i\n\n    self.error(f\"Empty parameters section at line {start_index}\")\n    return None, i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_return_section","title":"<code>read_return_section(lines, start_index)</code>","text":"<p>Parse an \"returns\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The return block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_return_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse an \"returns\" section.\n\n    Arguments:\n        lines: The return block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    text, i = self.read_block(lines, start_index)\n\n    # Early exit if there is no text in the return section\n    if not text:\n        self.error(f\"Empty return section at line {start_index}\")\n        return None, i\n\n    # First try to get the annotation and description from the docstring\n    try:\n        type_, text = text.split(\":\", 1)\n    except ValueError:\n        description = text\n        annotation = self.context[\"annotation\"]\n        # If there was no annotation in the docstring then move to signature\n        if annotation is empty and self.context[\"signature\"]:\n            annotation = self.context[\"signature\"].return_annotation\n    else:\n        annotation = type_.lstrip()\n        description = text.lstrip()\n\n    # There was no type in the docstring and no annotation\n    if annotation is empty:\n        self.error(\"No return type/annotation in docstring/signature\")\n\n    return Section(Section.Type.RETURN, AnnotatedObject(annotation, description)), i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.Google.read_yield_section","title":"<code>read_yield_section(lines, start_index)</code>","text":"<p>Parse a \"yields\" section.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The return block lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[Optional[Section], int]</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def read_yield_section(self, lines: list[str], start_index: int) -&gt; tuple[Optional[Section], int]:\n    \"\"\"Parse a \"yields\" section.\n\n    Arguments:\n        lines: The return block lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    text, i = self.read_block(lines, start_index)\n\n    # Early exit if there is no text in the yield section\n    if not text:\n        self.error(f\"Empty yield section at line {start_index}\")\n        return None, i\n\n    # First try to get the annotation and description from the docstring\n    try:\n        type_, text = text.split(\":\", 1)\n    except ValueError:\n        description = text\n        annotation = self.context[\"annotation\"]\n        # If there was no annotation in the docstring then move to signature\n        if annotation is empty and self.context[\"signature\"]:\n            annotation = self.context[\"signature\"].return_annotation\n    else:\n        annotation = type_.lstrip()\n        description = text.lstrip()\n\n    # There was no type in the docstring and no annotation\n    if annotation is empty:\n        self.error(\"No yield type/annotation in docstring/signature\")\n\n    return Section(Section.Type.YIELD, AnnotatedObject(annotation, description)), i\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/google/#pytkdocs.parsers.docstrings.google.is_empty_line","title":"<code>is_empty_line(line)</code>","text":"<p>Tell if a line is empty.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line is empty or composed of blanks only, False otherwise.</p> Source code in <code>src/pytkdocs/parsers/docstrings/google.py</code> <pre><code>def is_empty_line(line: str) -&gt; bool:\n    \"\"\"Tell if a line is empty.\n\n    Arguments:\n        line: The line to check.\n\n    Returns:\n        True if the line is empty or composed of blanks only, False otherwise.\n    \"\"\"\n    return not line.strip()\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/markdown/","title":"pytkdocs.parsers.docstrings.markdown","text":"<p>This module defines functions and classes to parse docstrings into structured data.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/markdown/#pytkdocs.parsers.docstrings.markdown.Markdown","title":"<code>Markdown</code>","text":"<p>               Bases: <code>Parser</code></p> <p>A Markdown docstrings parser.</p> Source code in <code>src/pytkdocs/parsers/docstrings/markdown.py</code> <pre><code>class Markdown(Parser):\n    \"\"\"A Markdown docstrings parser.\"\"\"\n\n    def parse_sections(self, docstring: str) -&gt; list[Section]:  # noqa: D102\n        return [Section(Section.Type.MARKDOWN, docstring)]\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/","title":"pytkdocs.parsers.docstrings.numpy","text":"<p>This module defines functions and classes to parse docstrings into structured data.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.RE_DOCTEST_BLANKLINE","title":"<code>RE_DOCTEST_BLANKLINE = re.compile('^\\\\s*&lt;BLANKLINE&gt;\\\\s*$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match lines of the form <code>&lt;BLANKLINE&gt;</code>.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.RE_DOCTEST_FLAGS","title":"<code>RE_DOCTEST_FLAGS = re.compile('(\\\\s*#\\\\s*doctest:.+)$')</code>  <code>module-attribute</code>","text":"<p>Regular expression to match lines containing doctest flags of the form <code># doctest: +FLAG</code>.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy","title":"<code>Numpy</code>","text":"<p>               Bases: <code>Parser</code></p> <p>A Numpy-style docstrings parser.</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>class Numpy(Parser):\n    \"\"\"A Numpy-style docstrings parser.\"\"\"\n\n    def __init__(self, trim_doctest_flags: bool = True, **kwargs: Any) -&gt; None:  # noqa: FBT001, FBT002, ARG002\n        \"\"\"Initialize the objects.\n\n        Arguments:\n            trim_doctest_flags: Whether to remove doctest flags.\n        \"\"\"\n        super().__init__()\n        self.trim_doctest_flags = trim_doctest_flags\n        self.section_reader = {\n            Section.Type.PARAMETERS: self.read_parameters_section,\n            Section.Type.EXCEPTIONS: self.read_exceptions_section,\n            Section.Type.EXAMPLES: self.read_examples_section,\n            Section.Type.ATTRIBUTES: self.read_attributes_section,\n            Section.Type.RETURN: self.read_return_section,\n        }\n\n    def parse_sections(self, docstring: str) -&gt; list[Section]:  # noqa: D102\n        if \"signature\" not in self.context:\n            self.context[\"signature\"] = getattr(self.context[\"obj\"], \"signature\", None)\n        if \"annotation\" not in self.context:\n            self.context[\"annotation\"] = getattr(self.context[\"obj\"], \"type\", empty)\n        if \"attributes\" not in self.context:\n            self.context[\"attributes\"] = {}\n\n        docstring_obj = parse(docstring)\n        description_all = (\n            none_str_cast(docstring_obj.short_description) + \"\\n\\n\" + none_str_cast(docstring_obj.long_description)\n        ).strip()\n        sections = [Section(Section.Type.MARKDOWN, description_all)] if description_all else []\n        sections_other = [\n            reader(docstring_obj) if sec == Section.Type.RETURN else reader(docstring, docstring_obj)  # type: ignore[operator]\n            for (sec, reader) in self.section_reader.items()\n        ]\n        sections.extend([sec for sec in sections_other if sec])\n        return sections\n\n    def read_parameters_section(\n        self,\n        docstring: str,\n        docstring_obj: Docstring,\n    ) -&gt; Optional[Section]:\n        \"\"\"Parse a \"parameters\" section.\n\n        Arguments:\n            docstring: The raw docstring.\n            docstring_obj: Docstring object parsed by docstring_parser.\n\n        Returns:\n            A `Section` object (or `None` if section is empty).\n        \"\"\"\n        parameters = []\n\n        docstring_params = [p for p in docstring_obj.params if p.args[0] == \"param\"]\n\n        for param in docstring_params:\n            name = param.arg_name\n            kind = None\n            type_name = param.type_name\n            default = param.default or empty\n            try:\n                signature_param = self.context[\"signature\"].parameters[name.lstrip(\"*\")]\n            except (AttributeError, KeyError):\n                self.error(f\"No type annotation for parameter '{name}'\")\n            else:\n                if signature_param.annotation is not empty:\n                    type_name = signature_param.annotation\n                if signature_param.default is not empty:\n                    default = signature_param.default\n                kind = signature_param.kind\n\n            description = param.description or \"\"\n            if not description:\n                self.error(f\"No description for parameter '{name}'\")\n\n            parameters.append(\n                Parameter(\n                    name=param.arg_name,\n                    annotation=type_name,\n                    description=description,\n                    default=default,\n                    kind=kind,\n                ),\n            )\n\n        if parameters:\n            return Section(Section.Type.PARAMETERS, parameters)\n        if re.search(\"Parameters\\n\", docstring):\n            self.error(\"Empty parameter section\")\n        return None\n\n    def read_attributes_section(\n        self,\n        docstring: str,\n        docstring_obj: Docstring,\n    ) -&gt; Optional[Section]:\n        \"\"\"Parse an \"attributes\" section.\n\n        Arguments:\n            docstring: The raw docstring.\n            docstring_obj: Docstring object parsed by docstring_parser.\n\n        Returns:\n            A `Section` object (or `None` if section is empty).\n        \"\"\"\n        attributes = []\n        docstring_attributes = [p for p in docstring_obj.params if p.args[0] == \"attribute\"]\n\n        for attr in docstring_attributes:\n            description = attr.description or \"\"\n            if not description:\n                self.error(f\"No description for attribute '{attr.arg_name}'\")\n            attributes.append(\n                Attribute(\n                    name=attr.arg_name,\n                    annotation=attr.type_name,\n                    description=description,\n                ),\n            )\n\n        if attributes:\n            return Section(Section.Type.ATTRIBUTES, attributes)\n        if re.search(\"Attributes\\n\", docstring):\n            self.error(\"Empty attributes section\")\n        return None\n\n    def read_exceptions_section(\n        self,\n        docstring: str,\n        docstring_obj: Docstring,\n    ) -&gt; Optional[Section]:\n        \"\"\"Parse an \"exceptions\" section.\n\n        Arguments:\n            docstring: The raw docstring.\n            docstring_obj: Docstring object parsed by docstring_parser.\n\n        Returns:\n            A `Section` object (or `None` if section is empty).\n        \"\"\"\n        exceptions = []\n        except_obj = docstring_obj.raises\n\n        for exception in except_obj:\n            description = exception.description or \"\"\n            if not description:\n                self.error(f\"No description for exception '{exception.type_name}'\")\n            exceptions.append(AnnotatedObject(exception.type_name, description))\n\n        if exceptions:\n            return Section(Section.Type.EXCEPTIONS, exceptions)\n        if re.search(\"Raises\\n\", docstring):\n            self.error(\"Empty exceptions section\")\n        return None\n\n    def read_return_section(\n        self,\n        docstring_obj: Docstring,\n    ) -&gt; Optional[Section]:\n        \"\"\"Parse a \"returns\" section.\n\n        Arguments:\n            docstring_obj: Docstring object parsed by docstring_parser.\n\n        Returns:\n            A `Section` object (or `None` if section is empty).\n        \"\"\"\n        if docstring_obj.returns:\n            return_obj = docstring_obj.returns\n\n            if return_obj.description:\n                description = return_obj.description\n            else:\n                self.error(\"Empty return description\")\n                description = \"\"\n\n            if self.context[\"signature\"]:\n                annotation = self.context[\"signature\"].return_annotation\n            else:\n                annotation = self.context[\"annotation\"]\n\n            if annotation is empty and return_obj.type_name:\n                annotation = return_obj.type_name\n\n            if not annotation:\n                self.error(\"No return type annotation\")\n                annotation = \"\"\n\n            if annotation or description:\n                return Section(Section.Type.RETURN, AnnotatedObject(annotation, description))\n\n        return None\n\n    def read_examples_section(\n        self,\n        docstring: str,\n        docstring_obj: Docstring,\n    ) -&gt; Optional[Section]:\n        \"\"\"Parse an \"examples\" section.\n\n        Arguments:\n            docstring: The raw docstring.\n            docstring_obj: Docstring object parsed by docstring_parser.\n\n        Returns:\n            A `Section` object (or `None` if section is empty).\n        \"\"\"\n        text = next(\n            (\n                meta.description\n                for meta in docstring_obj.meta\n                if isinstance(meta, DocstringMeta) and meta.args[0] == \"examples\"\n            ),\n            \"\",\n        )\n\n        sub_sections = []\n        in_code_example = False\n        in_code_block = False\n        current_text: list[str] = []\n        current_example: list[str] = []\n\n        if text:\n            for line in text.split(\"\\n\"):\n                if is_empty_line(line):\n                    if in_code_example:\n                        if current_example:\n                            sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n                            current_example = []\n                        in_code_example = False\n                    else:\n                        current_text.append(line)\n\n                elif in_code_example:\n                    if self.trim_doctest_flags:\n                        line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                        line = RE_DOCTEST_BLANKLINE.sub(\"\", line)  # noqa: PLW2901\n                    current_example.append(line)\n\n                elif line.startswith(\"```\"):\n                    in_code_block = not in_code_block\n                    current_text.append(line)\n\n                elif in_code_block:\n                    current_text.append(line)\n\n                elif line.startswith(\"&gt;&gt;&gt;\"):\n                    if current_text:\n                        sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n                        current_text = []\n                    in_code_example = True\n\n                    if self.trim_doctest_flags:\n                        line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                    current_example.append(line)\n                else:\n                    current_text.append(line)\n\n        if current_text:\n            sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n        elif current_example:\n            sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n\n        if sub_sections:\n            return Section(Section.Type.EXAMPLES, sub_sections)\n\n        if re.search(\"Examples\\n\", docstring):\n            self.error(\"Empty examples section\")\n        return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.__init__","title":"<code>__init__(trim_doctest_flags=True, **kwargs)</code>","text":"<p>Initialize the objects.</p> <p>Parameters:</p> Name Type Description Default <code>trim_doctest_flags</code> <code>bool</code> <p>Whether to remove doctest flags.</p> <code>True</code> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def __init__(self, trim_doctest_flags: bool = True, **kwargs: Any) -&gt; None:  # noqa: FBT001, FBT002, ARG002\n    \"\"\"Initialize the objects.\n\n    Arguments:\n        trim_doctest_flags: Whether to remove doctest flags.\n    \"\"\"\n    super().__init__()\n    self.trim_doctest_flags = trim_doctest_flags\n    self.section_reader = {\n        Section.Type.PARAMETERS: self.read_parameters_section,\n        Section.Type.EXCEPTIONS: self.read_exceptions_section,\n        Section.Type.EXAMPLES: self.read_examples_section,\n        Section.Type.ATTRIBUTES: self.read_attributes_section,\n        Section.Type.RETURN: self.read_return_section,\n    }\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.read_attributes_section","title":"<code>read_attributes_section(docstring, docstring_obj)</code>","text":"<p>Parse an \"attributes\" section.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The raw docstring.</p> required <code>docstring_obj</code> <code>Docstring</code> <p>Docstring object parsed by docstring_parser.</p> required <p>Returns:</p> Type Description <code>Optional[Section]</code> <p>A <code>Section</code> object (or <code>None</code> if section is empty).</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def read_attributes_section(\n    self,\n    docstring: str,\n    docstring_obj: Docstring,\n) -&gt; Optional[Section]:\n    \"\"\"Parse an \"attributes\" section.\n\n    Arguments:\n        docstring: The raw docstring.\n        docstring_obj: Docstring object parsed by docstring_parser.\n\n    Returns:\n        A `Section` object (or `None` if section is empty).\n    \"\"\"\n    attributes = []\n    docstring_attributes = [p for p in docstring_obj.params if p.args[0] == \"attribute\"]\n\n    for attr in docstring_attributes:\n        description = attr.description or \"\"\n        if not description:\n            self.error(f\"No description for attribute '{attr.arg_name}'\")\n        attributes.append(\n            Attribute(\n                name=attr.arg_name,\n                annotation=attr.type_name,\n                description=description,\n            ),\n        )\n\n    if attributes:\n        return Section(Section.Type.ATTRIBUTES, attributes)\n    if re.search(\"Attributes\\n\", docstring):\n        self.error(\"Empty attributes section\")\n    return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.read_examples_section","title":"<code>read_examples_section(docstring, docstring_obj)</code>","text":"<p>Parse an \"examples\" section.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The raw docstring.</p> required <code>docstring_obj</code> <code>Docstring</code> <p>Docstring object parsed by docstring_parser.</p> required <p>Returns:</p> Type Description <code>Optional[Section]</code> <p>A <code>Section</code> object (or <code>None</code> if section is empty).</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def read_examples_section(\n    self,\n    docstring: str,\n    docstring_obj: Docstring,\n) -&gt; Optional[Section]:\n    \"\"\"Parse an \"examples\" section.\n\n    Arguments:\n        docstring: The raw docstring.\n        docstring_obj: Docstring object parsed by docstring_parser.\n\n    Returns:\n        A `Section` object (or `None` if section is empty).\n    \"\"\"\n    text = next(\n        (\n            meta.description\n            for meta in docstring_obj.meta\n            if isinstance(meta, DocstringMeta) and meta.args[0] == \"examples\"\n        ),\n        \"\",\n    )\n\n    sub_sections = []\n    in_code_example = False\n    in_code_block = False\n    current_text: list[str] = []\n    current_example: list[str] = []\n\n    if text:\n        for line in text.split(\"\\n\"):\n            if is_empty_line(line):\n                if in_code_example:\n                    if current_example:\n                        sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n                        current_example = []\n                    in_code_example = False\n                else:\n                    current_text.append(line)\n\n            elif in_code_example:\n                if self.trim_doctest_flags:\n                    line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                    line = RE_DOCTEST_BLANKLINE.sub(\"\", line)  # noqa: PLW2901\n                current_example.append(line)\n\n            elif line.startswith(\"```\"):\n                in_code_block = not in_code_block\n                current_text.append(line)\n\n            elif in_code_block:\n                current_text.append(line)\n\n            elif line.startswith(\"&gt;&gt;&gt;\"):\n                if current_text:\n                    sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n                    current_text = []\n                in_code_example = True\n\n                if self.trim_doctest_flags:\n                    line = RE_DOCTEST_FLAGS.sub(\"\", line)  # noqa: PLW2901\n                current_example.append(line)\n            else:\n                current_text.append(line)\n\n    if current_text:\n        sub_sections.append((Section.Type.MARKDOWN, \"\\n\".join(current_text)))\n    elif current_example:\n        sub_sections.append((Section.Type.EXAMPLES, \"\\n\".join(current_example)))\n\n    if sub_sections:\n        return Section(Section.Type.EXAMPLES, sub_sections)\n\n    if re.search(\"Examples\\n\", docstring):\n        self.error(\"Empty examples section\")\n    return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.read_exceptions_section","title":"<code>read_exceptions_section(docstring, docstring_obj)</code>","text":"<p>Parse an \"exceptions\" section.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The raw docstring.</p> required <code>docstring_obj</code> <code>Docstring</code> <p>Docstring object parsed by docstring_parser.</p> required <p>Returns:</p> Type Description <code>Optional[Section]</code> <p>A <code>Section</code> object (or <code>None</code> if section is empty).</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def read_exceptions_section(\n    self,\n    docstring: str,\n    docstring_obj: Docstring,\n) -&gt; Optional[Section]:\n    \"\"\"Parse an \"exceptions\" section.\n\n    Arguments:\n        docstring: The raw docstring.\n        docstring_obj: Docstring object parsed by docstring_parser.\n\n    Returns:\n        A `Section` object (or `None` if section is empty).\n    \"\"\"\n    exceptions = []\n    except_obj = docstring_obj.raises\n\n    for exception in except_obj:\n        description = exception.description or \"\"\n        if not description:\n            self.error(f\"No description for exception '{exception.type_name}'\")\n        exceptions.append(AnnotatedObject(exception.type_name, description))\n\n    if exceptions:\n        return Section(Section.Type.EXCEPTIONS, exceptions)\n    if re.search(\"Raises\\n\", docstring):\n        self.error(\"Empty exceptions section\")\n    return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.read_parameters_section","title":"<code>read_parameters_section(docstring, docstring_obj)</code>","text":"<p>Parse a \"parameters\" section.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>str</code> <p>The raw docstring.</p> required <code>docstring_obj</code> <code>Docstring</code> <p>Docstring object parsed by docstring_parser.</p> required <p>Returns:</p> Type Description <code>Optional[Section]</code> <p>A <code>Section</code> object (or <code>None</code> if section is empty).</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def read_parameters_section(\n    self,\n    docstring: str,\n    docstring_obj: Docstring,\n) -&gt; Optional[Section]:\n    \"\"\"Parse a \"parameters\" section.\n\n    Arguments:\n        docstring: The raw docstring.\n        docstring_obj: Docstring object parsed by docstring_parser.\n\n    Returns:\n        A `Section` object (or `None` if section is empty).\n    \"\"\"\n    parameters = []\n\n    docstring_params = [p for p in docstring_obj.params if p.args[0] == \"param\"]\n\n    for param in docstring_params:\n        name = param.arg_name\n        kind = None\n        type_name = param.type_name\n        default = param.default or empty\n        try:\n            signature_param = self.context[\"signature\"].parameters[name.lstrip(\"*\")]\n        except (AttributeError, KeyError):\n            self.error(f\"No type annotation for parameter '{name}'\")\n        else:\n            if signature_param.annotation is not empty:\n                type_name = signature_param.annotation\n            if signature_param.default is not empty:\n                default = signature_param.default\n            kind = signature_param.kind\n\n        description = param.description or \"\"\n        if not description:\n            self.error(f\"No description for parameter '{name}'\")\n\n        parameters.append(\n            Parameter(\n                name=param.arg_name,\n                annotation=type_name,\n                description=description,\n                default=default,\n                kind=kind,\n            ),\n        )\n\n    if parameters:\n        return Section(Section.Type.PARAMETERS, parameters)\n    if re.search(\"Parameters\\n\", docstring):\n        self.error(\"Empty parameter section\")\n    return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.Numpy.read_return_section","title":"<code>read_return_section(docstring_obj)</code>","text":"<p>Parse a \"returns\" section.</p> <p>Parameters:</p> Name Type Description Default <code>docstring_obj</code> <code>Docstring</code> <p>Docstring object parsed by docstring_parser.</p> required <p>Returns:</p> Type Description <code>Optional[Section]</code> <p>A <code>Section</code> object (or <code>None</code> if section is empty).</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def read_return_section(\n    self,\n    docstring_obj: Docstring,\n) -&gt; Optional[Section]:\n    \"\"\"Parse a \"returns\" section.\n\n    Arguments:\n        docstring_obj: Docstring object parsed by docstring_parser.\n\n    Returns:\n        A `Section` object (or `None` if section is empty).\n    \"\"\"\n    if docstring_obj.returns:\n        return_obj = docstring_obj.returns\n\n        if return_obj.description:\n            description = return_obj.description\n        else:\n            self.error(\"Empty return description\")\n            description = \"\"\n\n        if self.context[\"signature\"]:\n            annotation = self.context[\"signature\"].return_annotation\n        else:\n            annotation = self.context[\"annotation\"]\n\n        if annotation is empty and return_obj.type_name:\n            annotation = return_obj.type_name\n\n        if not annotation:\n            self.error(\"No return type annotation\")\n            annotation = \"\"\n\n        if annotation or description:\n            return Section(Section.Type.RETURN, AnnotatedObject(annotation, description))\n\n    return None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/numpy/#pytkdocs.parsers.docstrings.numpy.is_empty_line","title":"<code>is_empty_line(line)</code>","text":"<p>Tell if a line is empty.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line is empty or composed of blanks only, False otherwise.</p> Source code in <code>src/pytkdocs/parsers/docstrings/numpy.py</code> <pre><code>def is_empty_line(line: str) -&gt; bool:\n    \"\"\"Tell if a line is empty.\n\n    Arguments:\n        line: The line to check.\n\n    Returns:\n        True if the line is empty or composed of blanks only, False otherwise.\n    \"\"\"\n    return not line.strip()\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/","title":"pytkdocs.parsers.docstrings.restructured_text","text":"<p>This module defines functions and classes to parse docstrings into structured data.</p>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.AttributesDict","title":"<code>AttributesDict</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attribute details.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>class AttributesDict(TypedDict):\n    \"\"\"Attribute details.\"\"\"\n\n    docstring: str\n    annotation: type  # TODO: Not positive this is correct\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.FieldType","title":"<code>FieldType</code>  <code>dataclass</code>","text":"<p>Maps directive names to parser functions.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>@dataclass(frozen=True)\nclass FieldType:\n    \"\"\"Maps directive names to parser functions.\"\"\"\n\n    names: frozenset[str]\n    reader: Callable[[list[str], int], int]\n\n    def matches(self, line: str) -&gt; bool:\n        \"\"\"Check if a line matches the field type.\n\n        Args:\n            line: Line to check against\n\n        Returns:\n            True if the line matches the field type, False otherwise.\n        \"\"\"\n        return any(line.startswith(f\":{name}\") for name in self.names)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.FieldType.matches","title":"<code>matches(line)</code>","text":"<p>Check if a line matches the field type.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Line to check against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the line matches the field type, False otherwise.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def matches(self, line: str) -&gt; bool:\n    \"\"\"Check if a line matches the field type.\n\n    Args:\n        line: Line to check against\n\n    Returns:\n        True if the line matches the field type, False otherwise.\n    \"\"\"\n    return any(line.startswith(f\":{name}\") for name in self.names)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.ParseContext","title":"<code>ParseContext</code>","text":"<p>Typed replacement for context dictionary.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>class ParseContext:\n    \"\"\"Typed replacement for context dictionary.\"\"\"\n\n    obj: Any  # I think this might be pytkdos.Object &amp; subclasses\n    attributes: defaultdict[str, AttributesDict]\n    signature: Optional[Signature]\n    # Not sure real type yet. Maybe Optional[Union[Literal[Signature.empty],str,Type]]\n    annotation: Any\n\n    # This might be be better as the obj &amp; optional attributes\n    def __init__(self, context: dict):\n        \"\"\"Initialize the object.\n\n        Args:\n            context: Context of parsing operation.\n        \"\"\"\n        self.obj = context[\"obj\"]\n        self.attributes = defaultdict(cast(Callable[[], AttributesDict], dict))\n        attributes = context.get(\"attributes\")\n        if attributes is not None:\n            self.attributes.update(attributes)\n\n        self.signature = getattr(self.obj, \"signature\", None)\n        self.annotation = getattr(self.obj, \"type\", empty)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.ParseContext.__init__","title":"<code>__init__(context)</code>","text":"<p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>Context of parsing operation.</p> required Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def __init__(self, context: dict):\n    \"\"\"Initialize the object.\n\n    Args:\n        context: Context of parsing operation.\n    \"\"\"\n    self.obj = context[\"obj\"]\n    self.attributes = defaultdict(cast(Callable[[], AttributesDict], dict))\n    attributes = context.get(\"attributes\")\n    if attributes is not None:\n        self.attributes.update(attributes)\n\n    self.signature = getattr(self.obj, \"signature\", None)\n    self.annotation = getattr(self.obj, \"type\", empty)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.ParsedDirective","title":"<code>ParsedDirective</code>  <code>dataclass</code>","text":"<p>Directive information that has been parsed from a docstring.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>@dataclass\nclass ParsedDirective:\n    \"\"\"Directive information that has been parsed from a docstring.\"\"\"\n\n    line: str\n    next_index: int\n    directive_parts: list[str]\n    value: str\n    invalid: bool = False\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.ParsedValues","title":"<code>ParsedValues</code>  <code>dataclass</code>","text":"<p>Values parsed from the docstring to be used to produce sections.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>@dataclass\nclass ParsedValues:\n    \"\"\"Values parsed from the docstring to be used to produce sections.\"\"\"\n\n    description: list[str] = field(default_factory=list)\n    parameters: dict[str, Parameter] = field(default_factory=dict)\n    param_types: dict[str, str] = field(default_factory=dict)\n    attributes: dict[str, Attribute] = field(default_factory=dict)\n    attribute_types: dict[str, str] = field(default_factory=dict)\n    exceptions: list[AnnotatedObject] = field(default_factory=list)\n    return_value: Optional[AnnotatedObject] = None\n    return_type: Optional[str] = None\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText","title":"<code>RestructuredText</code>","text":"<p>               Bases: <code>Parser</code></p> <p>A reStructuredText docstrings parser.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>class RestructuredText(Parser):\n    \"\"\"A reStructuredText docstrings parser.\"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:  # noqa: ARG002\n        \"\"\"Initialize the object.\"\"\"\n        super().__init__()\n        self._typed_context = ParseContext({\"obj\": None})\n        self._parsed_values: ParsedValues = ParsedValues()\n        # Ordering is significant so that directives like \":vartype\" are checked before \":var\"\n        self.field_types = [\n            FieldType(PARAM_TYPE_NAMES, self._read_parameter_type),\n            FieldType(PARAM_NAMES, self._read_parameter),\n            FieldType(ATTRIBUTE_TYPE_NAMES, self._read_attribute_type),\n            FieldType(ATTRIBUTE_NAMES, self._read_attribute),\n            FieldType(EXCEPTION_NAMES, self._read_exception),\n            FieldType(RETURN_NAMES, self._read_return),\n            FieldType(RETURN_TYPE_NAMES, self._read_return_type),\n        ]\n\n    def parse_sections(self, docstring: str) -&gt; list[Section]:  # noqa: D102\n        self._typed_context = ParseContext(self.context)\n        self._parsed_values = ParsedValues()\n\n        lines = docstring.split(\"\\n\")\n        curr_line_index = 0\n\n        while curr_line_index &lt; len(lines):\n            line = lines[curr_line_index]\n            for field_type in self.field_types:\n                if field_type.matches(line):\n                    # https://github.com/python/mypy/issues/5485\n                    curr_line_index = field_type.reader(lines, curr_line_index)\n                    break\n            else:\n                self._parsed_values.description.append(line)\n\n            curr_line_index += 1\n\n        return self._parsed_values_to_sections()\n\n    def _read_parameter(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse a parameter value.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n\n        directive_type = None\n        if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n            # no type info\n            name = parsed_directive.directive_parts[1]\n        elif len(parsed_directive.directive_parts) == 3:  # noqa: PLR2004\n            directive_type = parsed_directive.directive_parts[1]\n            name = parsed_directive.directive_parts[2]\n        else:\n            self.error(f\"Failed to parse field directive from '{parsed_directive.line}'\")\n            return parsed_directive.next_index\n\n        if name in self._parsed_values.parameters:\n            self.errors.append(f\"Duplicate parameter entry for '{name}'\")\n            return parsed_directive.next_index\n\n        annotation = self._determine_param_annotation(name, directive_type)\n        default, kind = self._determine_param_details(name)\n\n        self._parsed_values.parameters[name] = Parameter(\n            name=name,\n            annotation=annotation,\n            description=parsed_directive.value,\n            default=default,\n            kind=kind,\n        )\n\n        return parsed_directive.next_index\n\n    def _determine_param_details(self, name: str) -&gt; tuple[Any, Any]:\n        default = empty\n        kind = empty\n\n        if self._typed_context.signature is not None:\n            param_signature = self._typed_context.signature.parameters.get(name.lstrip(\"*\"))\n            # an error for param_signature being none is already reported by _determine_param_annotation()\n            if param_signature is not None:\n                if param_signature.default is not empty:\n                    default = param_signature.default\n                kind = param_signature.kind  # type: ignore[assignment]\n\n        return default, kind\n\n    def _determine_param_annotation(self, name: str, directive_type: Optional[str]) -&gt; Any:\n        # Annotation precedence:\n        # - signature annotation\n        # - in-line directive type\n        # - \"type\" directive type\n        # - empty\n        annotation = empty\n\n        parsed_param_type = self._parsed_values.param_types.get(name)\n        if parsed_param_type is not None:\n            annotation = parsed_param_type  # type: ignore[assignment]\n\n        if directive_type is not None:\n            annotation = directive_type  # type: ignore[assignment]\n\n        if directive_type is not None and parsed_param_type is not None:\n            self.error(f\"Duplicate parameter information for '{name}'\")\n\n        if self._typed_context.signature is not None:\n            try:\n                param_signature = self._typed_context.signature.parameters[name.lstrip(\"*\")]\n            except KeyError:\n                self.error(f\"No matching parameter for '{name}'\")\n            else:\n                if param_signature.annotation is not empty:\n                    annotation = param_signature.annotation\n\n        return annotation\n\n    def _read_parameter_type(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse a parameter type.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n        param_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n\n        if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n            param_name = parsed_directive.directive_parts[1]\n        else:\n            self.error(f\"Failed to get parameter name from '{parsed_directive.line}'\")\n            return parsed_directive.next_index\n\n        self._parsed_values.param_types[param_name] = param_type\n        param = self._parsed_values.parameters.get(param_name)\n        if param is not None:\n            if param.annotation is empty:\n                param.annotation = param_type\n            else:\n                self.error(f\"Duplicate parameter information for '{param_name}'\")\n        return parsed_directive.next_index\n\n    def _read_attribute(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse an attribute value.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n\n        if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n            name = parsed_directive.directive_parts[1]\n        else:\n            self.error(f\"Failed to parse field directive from '{parsed_directive.line}'\")\n            return parsed_directive.next_index\n\n        annotation = empty\n\n        # Annotation precedence:\n        # - external context type TODO: spend time understanding where this comes from\n        # - \"vartype\" directive type\n        # - empty\n\n        parsed_attribute_type = self._parsed_values.attribute_types.get(name)\n        if parsed_attribute_type is not None:\n            annotation = parsed_attribute_type  # type: ignore[assignment]\n\n        context_attribute_annotation = self._typed_context.attributes[name].get(\"annotation\")\n        if context_attribute_annotation is not None:\n            annotation = context_attribute_annotation  # type: ignore[assignment]\n\n        if name in self._parsed_values.attributes:\n            self.errors.append(f\"Duplicate attribute entry for '{name}'\")\n        else:\n            self._parsed_values.attributes[name] = Attribute(\n                name=name,\n                annotation=annotation,\n                description=parsed_directive.value,\n            )\n\n        return parsed_directive.next_index\n\n    def _read_attribute_type(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse a parameter type.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n        attribute_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n\n        if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n            attribute_name = parsed_directive.directive_parts[1]\n        else:\n            self.error(f\"Failed to get attribute name from '{parsed_directive.line}'\")\n            return parsed_directive.next_index\n\n        self._parsed_values.attribute_types[attribute_name] = attribute_type\n        attribute = self._parsed_values.attributes.get(attribute_name)\n        if attribute is not None:\n            if attribute.annotation is empty:\n                attribute.annotation = attribute_type\n            else:\n                self.error(f\"Duplicate attribute information for '{attribute_name}'\")\n        return parsed_directive.next_index\n\n    def _read_exception(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse an exceptions value.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n\n        if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n            ex_type = parsed_directive.directive_parts[1]\n            self._parsed_values.exceptions.append(AnnotatedObject(ex_type, parsed_directive.value))\n        else:\n            self.error(f\"Failed to parse exception directive from '{parsed_directive.line}'\")\n\n        return parsed_directive.next_index\n\n    def _read_return(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse an return value.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n\n        annotation = empty\n        # Annotation precedence:\n        # - signature annotation\n        # - \"rtype\" directive type\n        # - external context type TODO: spend time understanding where this comes from\n        # - empty\n        if self._typed_context.signature is not None and self._typed_context.signature.return_annotation is not empty:\n            annotation = self._typed_context.signature.return_annotation\n        elif self._parsed_values.return_type is not None:\n            annotation = self._parsed_values.return_type  # type: ignore[assignment]\n        else:\n            annotation = self._typed_context.annotation\n\n        self._parsed_values.return_value = AnnotatedObject(annotation, parsed_directive.value)\n\n        return parsed_directive.next_index\n\n    def _read_return_type(self, lines: list[str], start_index: int) -&gt; int:\n        \"\"\"Parse an return type value.\n\n        Arguments:\n            lines: The docstring lines.\n            start_index: The line number to start at.\n\n        Returns:\n            Index at which to continue parsing.\n        \"\"\"\n        parsed_directive = self._parse_directive(lines, start_index)\n        if parsed_directive.invalid:\n            return parsed_directive.next_index\n\n        return_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n        self._parsed_values.return_type = return_type\n        return_value = self._parsed_values.return_value\n        if return_value is not None:\n            if return_value.annotation is empty:\n                return_value.annotation = return_type\n            else:\n                self.error(\"Duplicate type information for return\")\n\n        return parsed_directive.next_index\n\n    def _parsed_values_to_sections(self) -&gt; list[Section]:\n        markdown_text = \"\\n\".join(_strip_blank_lines(self._parsed_values.description))\n        result = [Section(Section.Type.MARKDOWN, markdown_text)]\n        if self._parsed_values.parameters:\n            param_values = list(self._parsed_values.parameters.values())\n            result.append(Section(Section.Type.PARAMETERS, param_values))\n        if self._parsed_values.attributes:\n            attribute_values = list(self._parsed_values.attributes.values())\n            result.append(Section(Section.Type.ATTRIBUTES, attribute_values))\n        if self._parsed_values.return_value is not None:\n            result.append(Section(Section.Type.RETURN, self._parsed_values.return_value))\n        if self._parsed_values.exceptions:\n            result.append(Section(Section.Type.EXCEPTIONS, self._parsed_values.exceptions))\n        return result\n\n    def _parse_directive(self, lines: list[str], start_index: int) -&gt; ParsedDirective:\n        line, next_index = _consolidate_continuation_lines(lines, start_index)\n        try:\n            _, directive, value = line.split(\":\", 2)\n        except ValueError:\n            self.error(f\"Failed to get ':directive: value' pair from '{line}'\")\n            return ParsedDirective(line, next_index, [], \"\", invalid=True)\n\n        value = value.strip()\n        return ParsedDirective(line, next_index, directive.split(\" \"), value)\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the object.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"Initialize the object.\"\"\"\n    super().__init__()\n    self._typed_context = ParseContext({\"obj\": None})\n    self._parsed_values: ParsedValues = ParsedValues()\n    # Ordering is significant so that directives like \":vartype\" are checked before \":var\"\n    self.field_types = [\n        FieldType(PARAM_TYPE_NAMES, self._read_parameter_type),\n        FieldType(PARAM_NAMES, self._read_parameter),\n        FieldType(ATTRIBUTE_TYPE_NAMES, self._read_attribute_type),\n        FieldType(ATTRIBUTE_NAMES, self._read_attribute),\n        FieldType(EXCEPTION_NAMES, self._read_exception),\n        FieldType(RETURN_NAMES, self._read_return),\n        FieldType(RETURN_TYPE_NAMES, self._read_return_type),\n    ]\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_attribute","title":"<code>_read_attribute(lines, start_index)</code>","text":"<p>Parse an attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_attribute(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse an attribute value.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n\n    if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n        name = parsed_directive.directive_parts[1]\n    else:\n        self.error(f\"Failed to parse field directive from '{parsed_directive.line}'\")\n        return parsed_directive.next_index\n\n    annotation = empty\n\n    # Annotation precedence:\n    # - external context type TODO: spend time understanding where this comes from\n    # - \"vartype\" directive type\n    # - empty\n\n    parsed_attribute_type = self._parsed_values.attribute_types.get(name)\n    if parsed_attribute_type is not None:\n        annotation = parsed_attribute_type  # type: ignore[assignment]\n\n    context_attribute_annotation = self._typed_context.attributes[name].get(\"annotation\")\n    if context_attribute_annotation is not None:\n        annotation = context_attribute_annotation  # type: ignore[assignment]\n\n    if name in self._parsed_values.attributes:\n        self.errors.append(f\"Duplicate attribute entry for '{name}'\")\n    else:\n        self._parsed_values.attributes[name] = Attribute(\n            name=name,\n            annotation=annotation,\n            description=parsed_directive.value,\n        )\n\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_attribute_type","title":"<code>_read_attribute_type(lines, start_index)</code>","text":"<p>Parse a parameter type.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_attribute_type(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse a parameter type.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n    attribute_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n\n    if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n        attribute_name = parsed_directive.directive_parts[1]\n    else:\n        self.error(f\"Failed to get attribute name from '{parsed_directive.line}'\")\n        return parsed_directive.next_index\n\n    self._parsed_values.attribute_types[attribute_name] = attribute_type\n    attribute = self._parsed_values.attributes.get(attribute_name)\n    if attribute is not None:\n        if attribute.annotation is empty:\n            attribute.annotation = attribute_type\n        else:\n            self.error(f\"Duplicate attribute information for '{attribute_name}'\")\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_exception","title":"<code>_read_exception(lines, start_index)</code>","text":"<p>Parse an exceptions value.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A tuple containing a <code>Section</code> (or <code>None</code>) and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_exception(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse an exceptions value.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing a `Section` (or `None`) and the index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n\n    if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n        ex_type = parsed_directive.directive_parts[1]\n        self._parsed_values.exceptions.append(AnnotatedObject(ex_type, parsed_directive.value))\n    else:\n        self.error(f\"Failed to parse exception directive from '{parsed_directive.line}'\")\n\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_parameter","title":"<code>_read_parameter(lines, start_index)</code>","text":"<p>Parse a parameter value.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_parameter(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse a parameter value.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n\n    directive_type = None\n    if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n        # no type info\n        name = parsed_directive.directive_parts[1]\n    elif len(parsed_directive.directive_parts) == 3:  # noqa: PLR2004\n        directive_type = parsed_directive.directive_parts[1]\n        name = parsed_directive.directive_parts[2]\n    else:\n        self.error(f\"Failed to parse field directive from '{parsed_directive.line}'\")\n        return parsed_directive.next_index\n\n    if name in self._parsed_values.parameters:\n        self.errors.append(f\"Duplicate parameter entry for '{name}'\")\n        return parsed_directive.next_index\n\n    annotation = self._determine_param_annotation(name, directive_type)\n    default, kind = self._determine_param_details(name)\n\n    self._parsed_values.parameters[name] = Parameter(\n        name=name,\n        annotation=annotation,\n        description=parsed_directive.value,\n        default=default,\n        kind=kind,\n    )\n\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_parameter_type","title":"<code>_read_parameter_type(lines, start_index)</code>","text":"<p>Parse a parameter type.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_parameter_type(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse a parameter type.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n    param_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n\n    if len(parsed_directive.directive_parts) == 2:  # noqa: PLR2004\n        param_name = parsed_directive.directive_parts[1]\n    else:\n        self.error(f\"Failed to get parameter name from '{parsed_directive.line}'\")\n        return parsed_directive.next_index\n\n    self._parsed_values.param_types[param_name] = param_type\n    param = self._parsed_values.parameters.get(param_name)\n    if param is not None:\n        if param.annotation is empty:\n            param.annotation = param_type\n        else:\n            self.error(f\"Duplicate parameter information for '{param_name}'\")\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_return","title":"<code>_read_return(lines, start_index)</code>","text":"<p>Parse an return value.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_return(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse an return value.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n\n    annotation = empty\n    # Annotation precedence:\n    # - signature annotation\n    # - \"rtype\" directive type\n    # - external context type TODO: spend time understanding where this comes from\n    # - empty\n    if self._typed_context.signature is not None and self._typed_context.signature.return_annotation is not empty:\n        annotation = self._typed_context.signature.return_annotation\n    elif self._parsed_values.return_type is not None:\n        annotation = self._parsed_values.return_type  # type: ignore[assignment]\n    else:\n        annotation = self._typed_context.annotation\n\n    self._parsed_values.return_value = AnnotatedObject(annotation, parsed_directive.value)\n\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text.RestructuredText._read_return_type","title":"<code>_read_return_type(lines, start_index)</code>","text":"<p>Parse an return type value.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _read_return_type(self, lines: list[str], start_index: int) -&gt; int:\n    \"\"\"Parse an return type value.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        Index at which to continue parsing.\n    \"\"\"\n    parsed_directive = self._parse_directive(lines, start_index)\n    if parsed_directive.invalid:\n        return parsed_directive.next_index\n\n    return_type = _consolidate_descriptive_type(parsed_directive.value.strip())\n    self._parsed_values.return_type = return_type\n    return_value = self._parsed_values.return_value\n    if return_value is not None:\n        if return_value.annotation is empty:\n            return_value.annotation = return_type\n        else:\n            self.error(\"Duplicate type information for return\")\n\n    return parsed_directive.next_index\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text._consolidate_continuation_lines","title":"<code>_consolidate_continuation_lines(lines, start_index)</code>","text":"<p>Convert a docstring field into a single line if a line continuation exists.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The docstring lines.</p> required <code>start_index</code> <code>int</code> <p>The line number to start at.</p> required <p>Returns:</p> Type Description <code>tuple[str, int]</code> <p>A tuple containing the continued lines as a single string and the index at which to continue parsing.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _consolidate_continuation_lines(lines: list[str], start_index: int) -&gt; tuple[str, int]:\n    \"\"\"Convert a docstring field into a single line if a line continuation exists.\n\n    Arguments:\n        lines: The docstring lines.\n        start_index: The line number to start at.\n\n    Returns:\n        A tuple containing the continued lines as a single string and the index at which to continue parsing.\n    \"\"\"\n    curr_line_index = start_index\n    block = [lines[curr_line_index].lstrip()]\n\n    # start processing after first item\n    curr_line_index += 1\n    while curr_line_index &lt; len(lines) and not lines[curr_line_index].startswith(\":\"):\n        block.append(lines[curr_line_index].lstrip())\n        curr_line_index += 1\n\n    return \" \".join(block).rstrip(\"\\n\"), curr_line_index - 1\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text._consolidate_descriptive_type","title":"<code>_consolidate_descriptive_type(descriptive_type)</code>","text":"<p>Convert type descriptions with \"or\" into respective type signature.</p> <p>\"x or None\" or \"None or x\" -&gt; \"Optional[x]\" \"x or x\" or \"x or y[ or z [...]]\" -&gt; \"Union[x, y, ...]\"</p> <p>Parameters:</p> Name Type Description Default <code>descriptive_type</code> <code>str</code> <p>Descriptions of an item's type.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Type signature for descriptive type.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _consolidate_descriptive_type(descriptive_type: str) -&gt; str:\n    \"\"\"Convert type descriptions with \"or\" into respective type signature.\n\n    \"x or None\" or \"None or x\" -&gt; \"Optional[x]\"\n    \"x or x\" or \"x or y[ or z [...]]\" -&gt; \"Union[x, y, ...]\"\n\n    Args:\n        descriptive_type: Descriptions of an item's type.\n\n    Returns:\n        Type signature for descriptive type.\n    \"\"\"\n    types = descriptive_type.split(\"or\")\n    if len(types) == 1:\n        return descriptive_type\n    types = [pt.strip() for pt in types]\n    if len(types) == 2:  # noqa: PLR2004\n        if types[0] == \"None\":\n            return f\"Optional[{types[1]}]\"\n        if types[1] == \"None\":\n            return f\"Optional[{types[0]}]\"\n    return f\"Union[{','.join(types)}]\"\n</code></pre>"},{"location":"reference/pytkdocs/parsers/docstrings/restructured_text/#pytkdocs.parsers.docstrings.restructured_text._strip_blank_lines","title":"<code>_strip_blank_lines(lines)</code>","text":"<p>Remove lines with no text or only whitespace characters from the start and end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>Lines to be stripped.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list with the same contents, with any blank lines at the start or end removed.</p> Source code in <code>src/pytkdocs/parsers/docstrings/restructured_text.py</code> <pre><code>def _strip_blank_lines(lines: list[str]) -&gt; list[str]:\n    \"\"\"Remove lines with no text or only whitespace characters from the start and end of the list.\n\n    Args:\n        lines: Lines to be stripped.\n\n    Returns:\n        A list with the same contents, with any blank lines at the start or end removed.\n    \"\"\"\n    if not lines:\n        return lines\n\n    # remove blank lines from the start and end\n    content_found = False\n    initial_content = 0\n    final_content = 0\n    for index, line in enumerate(lines):\n        if line == \"\" or line.isspace():\n            if not content_found:\n                initial_content += 1\n        else:\n            content_found = True\n            final_content = index\n    return lines[initial_content : final_content + 1]\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}